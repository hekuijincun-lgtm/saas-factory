import { NextResponse } from "next/server";

export const runtime = "edge";

// --- base64url helpers (Edge-safe) ---
function b64(bytes: Uint8Array): string {
  let s = "";
  for (let i = 0; i < bytes.length; i++) s += String.fromCharCode(bytes[i]);
  return btoa(s);
}
function b64url(bytes: Uint8Array): string {
  return b64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}
function utf8(s: string): Uint8Array {
  return new TextEncoder().encode(s);
}
function jsonB64url(obj: unknown): string {
  return b64url(utf8(JSON.stringify(obj)));
}

async function hmacSha256Base64url(data: string, secret: string): Promise<string> {
  const key = await crypto.subtle.importKey(
    "raw",
    utf8(secret),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );
  const sig = new Uint8Array(await crypto.subtle.sign("HMAC", key, utf8(data)));
  return b64url(sig);
}

async function signSession(payload: object, secret: string): Promise<string> {
  // minimal JWT-like token (header.payload.signature) for cookie session
  const header = { alg: "HS256", typ: "JWT" };
  const body = { ...payload, iat: Math.floor(Date.now() / 1000) };

  const hp = `${jsonB64url(header)}.${jsonB64url(body)}`;
  const sig = await hmacSha256Base64url(hp, secret);
  return `${hp}.${sig}`;
}

export async function GET(req: Request) {
  // NOTE: keep your existing callback logic here.
  // This patch focuses on removing Node-only crypto/Buffer usage.

  // Example: if you already compute payload/secret elsewhere, plug them in.
  // const secret = process.env.SESSION_SECRET ?? "";
  // const token = await signSession({ tenantId: "default" }, secret);

  return NextResponse.json({ ok: true, patched: true });
}