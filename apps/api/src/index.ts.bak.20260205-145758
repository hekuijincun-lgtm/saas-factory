import { Hono } from "hono"
import {
  getIntegration,
  upsertIntegration,
  setNotifyEnabled,
  disconnectIntegration,
  insertSendLog,
} from "./integrations/line/store"

// SAAS-FACTORY API ENTRY (apps/api/src/index.ts)
import { getMessagingStatus, saveMessagingConfig, deleteMessagingConfig } from "./integrations/line/messaging"

export { SlotLock } from "./durable/SlotLock";

type Env = {
  DB: D1Database
  LINE_CLIENT_ID?: string
  LINE_LOGIN_CHANNEL_ID?: string
  LINE_LOGIN_CHANNEL_SECRET?: string
  LINE_LOGIN_REDIRECT_BASE?: string
  LINE_CHANNEL_ACCESS_TOKEN?: string
  LINE_MESSAGING_CHANNEL_ACCESS_TOKEN?: string
}

const app = new Hono<{ Bindings: Env }>()

/* ===== FIX7: SlotLock entrypoint export ===== */
// Wrangler Âà§ÂÆöÁî®Ôºöentrypoint „Åß export class SlotLock „ÇíÁõ¥Êé•Ë¶ã„Åõ„Çã
/* ===== END FIX7 ===== */

/* ===== FIX6: RESTORE LOCALS (DEFAULT_ADMIN_SETTINGS + getBusinessHoursForDate) ===== */
const DEFAULT_ADMIN_SETTINGS = {
  timezone: "Asia/Tokyo",
  slotMinutes: 30,
  cutoffMinutes: 0,
  businessHours: { start: "09:00", end: "20:00" },
  closedWeekdays: [],
} as const;
function getBusinessHoursForDate(...args: any[]) {
  // Signature-agnostic: tries to locate a settings-like object in args.
  const settings =
    args.find(a => a && typeof a === "object" && (a.businessHours || a.closedWeekdays || a.timezone)) ??
    DEFAULT_ADMIN_SETTINGS;

  const dateArg = args.find(a => typeof a === "string" || a instanceof Date) ?? null;

  // If closedWeekdays matches weekday (0=Sun..6=Sat), mark closed.
  try {
    if(dateArg && Array.isArray((settings as any).closedWeekdays) && (settings as any).closedWeekdays.length){
      const d = (dateArg instanceof Date) ? dateArg : new Date(String(dateArg) + "T00:00:00+09:00");
      const wd = d.getDay();
      if((settings as any).closedWeekdays.includes(wd)){
        return { start: "00:00", end: "00:00", closed: true };
      }
    }
  } catch {}

  return (settings as any).businessHours ?? { start: "09:00", end: "20:00" };
}
/* ===== END FIX6 ===== */


app.get("/admin/integrations/line/messaging/status", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? "default"
    const db = (c.env as any).DB
    const env = c.env as any
    const r = await getMessagingStatus(env, db, tenantId)
    return c.json(r, 200)
  } catch (e) {
    const msg = e instanceof Error ? e.message : "unknown"
    return c.json({ ok: false, error: "internal_server_error", message: msg }, 500)
  }
})

app.post("/admin/integrations/line/messaging/save", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? "default"
    const body = await c.req.json()
    const db = (c.env as any).DB
    const env = c.env as any
    const r = await saveMessagingConfig(env, db, tenantId, body)
    if (r?.ok === false) return c.json(r, 400)
    return c.json(r, 200)
  } catch (e) {
    const msg = e instanceof Error ? e.message : "unknown"
    return c.json({ ok: false, error: "internal_server_error", message: msg }, 500)
  }
})

app.delete("/admin/integrations/line/messaging", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? "default"
    const db = (c.env as any).DB
    const env = c.env as any
    const r = await deleteMessagingConfig(env, db, tenantId)
    return c.json(r, 200)
  } catch (e) {
    const msg = e instanceof Error ? e.message : "unknown"
    return c.json({ ok: false, error: "internal_server_error", message: msg }, 500)
  }
})
// „É´„Éº„Éà: POST /admin/integrations/line/webhook
app.post("/admin/integrations/line/webhook", async (c) => {
  const tenantId = c.req.query("tenantId") ?? "default"
  const logId = crypto.randomUUID()
  const ts = new Date().toISOString()

  // 1) „Åæ„Åö„ÅØ raw „ÇíË™≠„ÇÄÔºàJSON„ÅåÂ£ä„Çå„Å¶„Å¶„ÇÇËêΩ„Å°„Å™„ÅÑÔºâ
  let raw = ""
  try {
    raw = await c.req.text()
  } catch {
    raw = ""
  }
  const bodyLen = raw.length

  // 2) ÊúÄ‰ΩéÈôê„Å†„ÅëÊäú„ÅèÔºàÂ§±Êïó„Åó„Å¶„ÇÇ nullÔºâ
  let eventType: string | null = null
  let msgType: string | null = null
  let replyToken: string | null = null
  let replyTokenLen: number | null = null
  let text: string | null = null

  try {
    const j = raw ? JSON.parse(raw) : null
    const ev = j?.events?.[0]
    if (ev) {
      eventType = (ev.type ?? null) as any
      msgType = (ev.message?.type ?? null) as any
      replyToken = (ev.replyToken ?? null) as any
      replyTokenLen = replyToken ? String(replyToken).length : null
      text = (ev.message?.text ?? null) as any
    }
  } catch {
    // ignore
  }

  // 3) dummy / no token / no text „ÅØ reply „Çí„Çπ„Ç≠„ÉÉ„ÉóÔºà0=skippedÔºâ
  const isDummy = replyToken === "dummy"
    // === BOOKING_LINK_BEGIN ===
    {
      const t = String((text as any) ?? '').trim();
      const norm = t.replace(/\s+/g,'');
      const isBooking =
        norm === '‰∫àÁ¥Ñ' ||
        norm === '„Çà„ÇÑ„Åè' ||
        norm === 'reserve' ||
        norm.startsWith('‰∫àÁ¥Ñ') ||
        norm.includes('‰∫àÁ¥Ñ');

      if (isBooking) {
        const u = String((c.env as any).BOOKING_URL ?? '').trim();
        const url = u || 'https://9e5cb6a9.booking-ui-4pk-3y1.pages.dev';

        const accessToken = String(
          (c.env as any).LINE_CHANNEL_ACCESS_TOKEN ??
          (c.env as any).LINE_MESSAGING_CHANNEL_ACCESS_TOKEN ??
          ''
        ).trim();

        if (!accessToken) {
          console.log('[BOOKING_URL] access token missing');
          return;
        }

        // Buttons template (best UX)
        const payload = {
          replyToken,
          messages: [
            {
              type: 'template',
              altText: '‰∫àÁ¥Ñ„Éö„Éº„Ç∏„ÇíÈñã„Åè',
              template: {
                type: 'buttons',
                title: '‰∫àÁ¥Ñ„Éö„Éº„Ç∏',
                text: '‰∏ã„ÅÆ„Éú„Çø„É≥„Åã„Çâ‰∫àÁ¥Ñ„ÇíÈñãÂßã„Åó„Å¶„Å≠üòô',
                actions: [
                  { type: 'uri', label: '‰∫àÁ¥Ñ„ÇíÈñãÂßã', uri: url }
                ]
              }
            }
          ]
        };

        try {
          const r = await fetch('https://api.line.me/v2/bot/message/reply', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ' + accessToken
            },
            body: JSON.stringify(payload)
          });
          if (!r.ok) {
            const body = await r.text().catch(() => '');
            console.log('[BOOKING_URL] reply failed', r.status, body);
          }
        } catch (e) {
          console.log('[BOOKING_URL] reply exception', String(e));
        }
        return;
      }
    }
    // === BOOKING_LINK_END ===
const shouldSkip = !replyToken || isDummy || !text
  const replyStatus = shouldSkip ? 0 : 1 // 0=skipped, 1=queued(Âæå„ÅßÂÆüË°å)

  // 4) „Åì„Åì„ÅåËÇùÔºöDB„ÇÑfetch„ÅØÂÖ®ÈÉ® waitUntil „Å´Êäï„Åí„Å¶„ÄÅHTTP„ÅØÂç≥Ëøî„Åô
  try {
    const work = (async () => {
      try {
        // table ensureÔºà„Åì„Åì„ÅåÂõ∫„Åæ„Å£„Å¶„ÇÇHTTP„ÅØËøî„Å£„ÅüÂæåÔºâ
        await c.env.DB.prepare(
          "CREATE TABLE IF NOT EXISTS line_webhook_logs (" +
            "id TEXT PRIMARY KEY," +
            "ts TEXT NOT NULL," +
            "tenant_id TEXT NOT NULL," +
            "event_type TEXT," +
            "msg_type TEXT," +
            "reply_token_len INTEGER," +
            "body_len INTEGER NOT NULL," +
            "reply_status INTEGER," +
            "reply_body TEXT" +
          ")"
        ).run()

        await c.env.DB.prepare(
          "CREATE INDEX IF NOT EXISTS idx_line_webhook_logs_tenant_ts " +
          "ON line_webhook_logs(tenant_id, ts)"
        ).run()

        // „Åæ„Åö„ÅØ„É≠„Ç∞„ÇíÂÖ•„Çå„ÇãÔºàqueued / skippedÔºâ
        const initialBody =
          shouldSkip
            ? (isDummy ? "reply skipped (dummy replyToken)" : "no replyToken or text")
            : "queued"

        await c.env.DB.prepare(
          "INSERT INTO line_webhook_logs (id, ts, tenant_id, event_type, msg_type, reply_token_len, body_len, reply_status, reply_body) " +
          "VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)"
        )
          .bind(logId, ts, tenantId, eventType, msgType, replyTokenLen, bodyLen, shouldSkip ? 0 : 1, initialBody)
          .run()

        // reply „ÅåÂøÖË¶Å„Å™Â†¥Âêà„Å†„ÅëÂÆüË°å
        if (!shouldSkip) {
          const token = resolveLineChannelAccessToken(c.env)
          if (!token) {
            await c.env.DB.prepare(
              "UPDATE line_webhook_logs SET reply_status = ?2, reply_body = ?3 WHERE id = ?1"
            ).bind(logId, -1, "LINE_CHANNEL_ACCESS_TOKEN missing").run()
            return
          }

          // Reply APIÔºà3Áßí„ÅßÊâì„Å°Âàá„ÇäÔºâ
          const ac = new AbortController()
          const t = setTimeout(() => ac.abort(), 3000)

          let status: number | null = null
          let body: string | null = null

          try {
            const r = await fetch("https://api.line.me/v2/bot/message/reply", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": "Bearer " + token,
              },
              body: JSON.stringify({
                replyToken,
                messages: [{ type: "text",
    text: "ok" }],
              }),
              signal: ac.signal,
            })
            status = r.status
            body = await r.text()
          } catch (e: any) {
            body = "fetch error: " + String(e?.message ?? e)
            status = -2
          } finally {
            clearTimeout(t)
          }

          // ÁµêÊûú„ÇíËøΩË®ò
          await c.env.DB.prepare(
            "UPDATE line_webhook_logs SET reply_status = ?2, reply_body = ?3 WHERE id = ?1"
          )
            .bind(logId, status, (body ?? "").slice(0, 2000))
            .run()
        }
      } catch {
        // ignoreÔºà„É≠„Ç∞Â§±Êïó„Åß„ÇÇOKÔºâ
      }
    })()

    // Âûã„Åå„ÅÜ„Çã„Åï„ÅÑÊôÇ„Åå„ÅÇ„Çã„ÅÆ„Åß any „ÅßÈÄÉ„Åå„ÅôÔºàÂÆüÈÅãÁî®ÂÑ™ÂÖàÔºâ
    ;(c as any).executionCtx?.waitUntil?.(work)
  } catch {
    // ignore
  }

  return c.json({ ok: true, logged: true, logId, replyStatus })
})

// „É´„Éº„Éà: GET /admin/integrations/line/webhook-logs
// Webhook„É≠„Ç∞‰∏ÄË¶ßÂèñÂæó
app.get("/admin/integrations/line/webhook-logs", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? "default"
    const limit = Math.min(parseInt(c.req.query("limit") || "30", 10), 200)

    const rows = await c.env.DB.prepare(
      "SELECT id, ts, tenant_id, event_type, msg_type, reply_status FROM line_webhook_logs WHERE tenant_id = ?1 ORDER BY ts DESC LIMIT ?2"
    )
      .bind(tenantId, limit)
      .all<{
        id: string
        ts: string
        tenant_id: string
        event_type: string | null
        msg_type: string | null
        reply_status: number | null
      }>()

    return c.json({
      ok: true,
      rows: rows.results || [],
    })
  } catch (e: any) {
    return c.json(
      { ok: false, error: "internal_error", message: String(e?.message ?? e) },
      500
    )
  }
})

// „É´„Éº„Éà: GET /admin/integrations/line/webhook-log
// Webhook„É≠„Ç∞Ë©≥Á¥∞ÂèñÂæó
app.get("/admin/integrations/line/webhook-log", async (c) => {
  try {
    const id = c.req.query("id")
    if (!id) {
      return c.json({ ok: false, error: "missing_id" }, 400)
    }

    const row = await c.env.DB.prepare(
      "SELECT * FROM line_webhook_logs WHERE id = ?1 LIMIT 1"
    )
      .bind(id)
      .first<{
        id: string
        ts: string
        tenant_id: string
        event_type: string | null
        msg_type: string | null
        reply_token_len: number | null
        body_len: number
        reply_status: number | null
        reply_body: string | null
      }>()

    if (!row) {
      return c.json({ ok: false, error: "not_found" }, 404)
    }

    return c.json({
      ok: true,
      log: row,
    })
  } catch (e: any) {
    return c.json(
      { ok: false, error: "internal_error", message: String(e?.message ?? e) },
      500
    )
  }
})

// „É´„Éº„Éà: GET /ping
app.get("/ping", (c) => c.text("pong"))


// POST /admin/integrations/line/oauth/callback
app.post('/admin/integrations/line/oauth/callback', async (c) => {
  try {
    const body = await c.req.json<{ code?: string; state?: string }>();

    // code „Å® state „ÅÆ„Éê„É™„Éá„Éº„Ç∑„Éß„É≥
    if (!body.code || typeof body.code !== 'string' || body.code.trim() === '') {
      return c.json({ ok: false, error: 'code is required' }, 400);
    }
    if (!body.state || typeof body.state !== 'string' || body.state.trim() === '') {
      return c.json({ ok: false, error: 'state is required' }, 400);
    }

    // state „Åã„Çâ tenantId „ÇíÊäΩÂá∫
    const stateParts = body.state.split(':');
    const tenantId = stateParts[0]?.trim();
    if (!tenantId) {
      return c.json({ ok: false, error: 'Invalid state: tenantId is missing' }, 400);
    }

    // Áí∞Â¢ÉÂ§âÊï∞„Åã„Çâ LINE Ë®≠ÂÆö„ÇíÂèñÂæó
    const clientId = c.env.LINE_CLIENT_ID;
    const clientSecret = c.env.LINE_LOGIN_CHANNEL_SECRET;
    
    // redirect_uri „ÇíÂèñÂæóÔºàÁí∞Â¢ÉÂ§âÊï∞„Åå„ÅÇ„Çå„Å∞„Åù„Çå„Çí‰ΩøÁî®„ÄÅ„Å™„Åë„Çå„Å∞ÊßãÁØâÔºâ
    let redirectUri: string;
    if (c.env.LINE_REDIRECT_URI) {
      redirectUri = c.env.LINE_REDIRECT_URI;
    } else if (c.env.LINE_LOGIN_REDIRECT_BASE) {
      redirectUri = `${c.env.LINE_LOGIN_REDIRECT_BASE.replace(/\/$/, '')}/admin/integrations/line/callback`;
    } else {
      return c.json({ ok: false, error: 'LINE_REDIRECT_URI or LINE_LOGIN_REDIRECT_BASE is not configured' }, 500);
    }

    if (!clientId) {
      return c.json({ ok: false, error: 'LINE_CLIENT_ID is not configured' }, 500);
    }
    if (!clientSecret) {
      return c.json({ ok: false, error: 'LINE_LOGIN_CHANNEL_SECRET is not configured' }, 500);
    }

    // LINE token „Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„ÇíÂè©„Åè
    let tokenResponse: {
      access_token: string;
      expires_in: number;
      token_type: string;
      refresh_token?: string;
      id_token?: string;
    };

    try {
      tokenResponse = await exchangeCodeForToken(body.code, clientId, clientSecret, redirectUri);
    } catch (tokenError) {
      // LINE token API „ÅÆ„Ç®„É©„Éº„Çí„É≠„Ç∞„Å´Âá∫Âäõ
      const errorMessage = tokenError instanceof Error ? tokenError.message : String(tokenError);
      console.error('[LINE OAuth Callback] Token exchange failed:', {
        status: errorMessage.includes('status') ? errorMessage : 'unknown',
        error: errorMessage,
        tenantId,
      });
      return c.json({ ok: false, error: 'line_token_error' }, 500);
    }

    // expires_at „ÇíË®àÁÆó
    const now = Math.floor(Date.now() / 1000);
    const expiresAt = now + tokenResponse.expires_in;

    // D1 „Å´ upsert
    const db = c.env.DB;
    const createdAt = now;
    const updatedAt = now;

    try {
      await db
        .prepare(
          `INSERT INTO line_connections
            (tenant_id, access_token, refresh_token, id_token, expires_at, created_at, updated_at)
          VALUES (?, ?, ?, ?, ?, ?, ?)
          ON CONFLICT(tenant_id) DO UPDATE SET
            access_token = excluded.access_token,
            refresh_token = excluded.refresh_token,
            id_token = excluded.id_token,
            expires_at = excluded.expires_at,
            updated_at = excluded.updated_at`
        )
        .bind(
          tenantId,
          tokenResponse.access_token,
          tokenResponse.refresh_token || null,
          tokenResponse.id_token || null,
          expiresAt,
          createdAt,
          updatedAt
        )
        .run();
    } catch (dbError) {
      console.error('[LINE OAuth Callback] D1 upsert failed:', {
        error: dbError instanceof Error ? dbError.message : String(dbError),
        tenantId,
      });
      return c.json({ ok: false, error: 'database_error' }, 500);
    }

    // ÊàêÂäü„É¨„Çπ„Éù„É≥„Çπ
    return c.json({ ok: true });
  } catch (error) {
    // JSON„Éë„Éº„Çπ„Ç®„É©„Éº„Å™„Å©
    if (error instanceof SyntaxError) {
      return c.json({ ok: false, error: 'Invalid JSON body' }, 400);
    }
    console.error('[LINE OAuth Callback] Unexpected error:', error);
    return c.json({ ok: false, error: error instanceof Error ? error.message : String(error) }, 500);
  }
});

//

export default app



