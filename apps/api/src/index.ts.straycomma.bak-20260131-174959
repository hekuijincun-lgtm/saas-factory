import { Hono } from "hono"
import {
  getIntegration,
  upsertIntegration,
  setNotifyEnabled,
  disconnectIntegration,
  insertSendLog,
} from "./integrations/line/store"

// SAAS-FACTORY API ENTRY (apps/api/src/index.ts)
type Env = {
  DB: D1Database
  LINE_CLIENT_ID?: string
  LINE_LOGIN_CHANNEL_ID?: string
  LINE_LOGIN_CHANNEL_SECRET?: string
  LINE_LOGIN_REDIRECT_BASE?: string
  LINE_CHANNEL_ACCESS_TOKEN?: string
  LINE_MESSAGING_CHANNEL_ACCESS_TOKEN?: string
}

const app = new Hono<{ Bindings: Env }>()

// tenantId がなければ default
const getTenantId = (req: Request): string => {
  const url = new URL(req.url)
  return url.searchParams.get("tenantId") ?? "default"
}

function resolveLineClientId(env: Env): string {
  return env.LINE_CLIENT_ID || env.LINE_LOGIN_CHANNEL_ID || ""
}

function resolveLineChannelAccessToken(env: Env): string {
  return env.LINE_CHANNEL_ACCESS_TOKEN || env.LINE_MESSAGING_CHANNEL_ACCESS_TOKEN || ""
}

async function pushLineMessage(env: Env, to: string, text: string): Promise<Response> {
  const token = resolveLineChannelAccessToken(env)
  if (!token) {
    return new Response(JSON.stringify({ ok: false, error: "LINE channel access token missing" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    })
  }

  return fetch("https://api.line.me/v2/bot/message/push", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": "Bearer " + token,
    },
    body: JSON.stringify({
      to,
      messages: [{ type: "text", text }],
    }),
  })
}

// ルート: GET /
app.get("/", (c) => c.text("Hello from SaaS Factory API!"))

// ルート: GET /health
app.get("/health", (c) => {
  return c.json({
    ok: true,
    ts: new Date().toISOString(),
    env: "development",
    version: "1.0.0",
  })
})

app.get("/__debug_guard", (c) => {
  return c.json({ ok: true, guard: "vD1-GUARD-20260125" })
})

// ルート: GET /admin/integrations/line/auth-url?tenantId=xxx
// LINE OAuth 認証URLを生成するエンドポイント
app.get("/admin/integrations/line/auth-url", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? "default"
    const env = c.env

    // client_id 解決（既存ロジックを維持）
    const clientId = resolveLineClientId(env)

    // redirect_uri を構築（Next.js 側の callback に向ける）
    // ★ ここがポイント：
    //     .dev.vars の LINE_LOGIN_REDIRECT_BASE をそのまま使う
    //     例: http://localhost:3000  または http://localhost:8787
    const redirectBase = env.LINE_LOGIN_REDIRECT_BASE ?? "http://localhost:3000"
    const redirectUri = `${redirectBase.replace(/\/$/, "")}/admin/integrations/line/callback`

    if (!clientId) {
      return c.json(
        { ok: false, error: "LINE_CLIENT_ID is not configured" },
        400,
      )
    }

    const params = new URLSearchParams({
      response_type: "code",
      client_id: clientId,
      redirect_uri: redirectUri,
      scope: "profile openid",
      state: tenantId,
    })

    const url = `https://access.line.me/oauth2/v2.1/authorize?${params.toString()}`

    return c.json({ ok: true, url })
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error"
    console.error("[LINE OAuth] auth-url error:", errorMessage)

    return c.json(
      {
        ok: false,
        error: "internal_server_error",
        message: `LINE OAuth認証URLの生成に失敗しました: ${errorMessage}`,
      },
      500,
    )
  }
})

// ルート: GET /admin/integrations/line/status
app.get("/admin/integrations/line/status", async (c) => {
  try {
    const tenantId = getTenantId(c.req.raw)
    const db = c.env.DB

    const integration = await getIntegration(db, tenantId)

    if (!integration) {
      return c.json({
        ok: true,
        tenantId,
        kind: "unconfigured" as const,
      })
    }

    return c.json({
      ok: true,
      tenantId,
      kind: "linked" as const,
      line: {
        userId: integration.user_id,
        displayName: integration.display_name,
        pictureUrl: integration.picture_url || undefined,
        updatedAt: integration.updated_at,
      },
      notifyEnabled: integration.notify_enabled === 1,
      linkedAt: integration.linked_at,
    })
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error"
    console.error("[LINE][status] error:", errorMessage)
    return c.json({
      ok: false,
      tenantId: getTenantId(c.req.raw),
      kind: "error" as const,
      message: "Failed to fetch LINE integration status",
      error: errorMessage,
    }, 500)
  }
})

// GET /admin/integrations/line/callback
// LINE Login は GET で code/state を返すので、既存の POST ハンドラへ橋渡しする
app.get("/admin/integrations/line/callback__old", async (c) => {
  const url = new URL(c.req.url)
  console.log("[LINE OAuth][callback:get] url=", url.toString())
  console.log("[LINE OAuth][callback:get] qs=", url.searchParams.toString())
  const code = url.searchParams.get("code")
  const state = url.searchParams.get("state") ?? "default"

  if (!code) return c.json({ ok: false, error: "missing code" }, 400)

  // 同一 Worker 内の POST /admin/integrations/line/callback に転送
  const forwardUrl = new URL(c.req.url)
  forwardUrl.pathname = "/admin/integrations/line/callback"
  forwardUrl.search = ""

  const res = await fetch(forwardUrl.toString(), {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ code, state }),
  })

  const txt = await res.text().catch(() => "")
  if (!res.ok) {
    return c.json(
      { ok: false, error: "callback forward failed", status: res.status, detail: txt },
      400
    )
  }

  // POST が JSON を返す前提。返さないなら txt を返す。
  try {
    return c.json(JSON.parse(txt))
  } catch {
    return c.text(txt)
  }
})

app.get("/admin/integrations/line/callback__old", async (c) => {
  const url = new URL(c.req.url)
  console.log("[LINE OAuth][callback:get] url=", url.toString())
  console.log("[LINE OAuth][callback:get] qs=", url.searchParams.toString())
  const code = url.searchParams.get("code") ?? ""
  const state = url.searchParams.get("state") ?? ""
  const tenantId = url.searchParams.get("tenantId") ?? state ?? getTenantId(c.req.raw)

  if (!code) {
    return c.redirect("http://127.0.0.1:3000/admin/settings?line=error_no_code", 307)
  }

  const res = await fetch("http://localhost:8787/admin/integrations/line/callback", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ code, state, tenantId }),
  })

  const txt = await res.text()
  console.log("[LINE OAuth][callback:get->post] status=", res.status, "body=", txt)

  if (res.ok) {
    return c.redirect("http://127.0.0.1:3000/admin/settings?line=ok", 307)
  }
  return c.redirect("http://127.0.0.1:3000/admin/settings?line=error_token", 307)
})
/** GET /admin/integrations/line/callback
 * LINE OAuth redirect endpoint (browser -> worker).
 * Forwards to POST handler to reuse token-exchange logic.
 */
app.get("/admin/integrations/line/callback", async (c) => {
  const url = new URL(c.req.url)
  console.log("[LINE OAuth][callback:get] url=", url.toString())
  console.log("[LINE OAuth][callback:get] qs=", url.searchParams.toString())
  const code = url.searchParams.get("code") ?? ""
  const state = url.searchParams.get("state") ?? ""
  const tenantId = url.searchParams.get("tenantId") ?? state ?? getTenantId(c.req.raw)

  if (!code) {
    return c.redirect("http://127.0.0.1:3000/admin/settings?line=error_no_code", 307)
  }

  const res = await fetch("http://localhost:8787/admin/integrations/line/callback", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ code, state, tenantId }),
  })

  const txt = await res.text()
  console.log("[LINE OAuth][callback:get->post] status=", res.status, "body=", txt)

  if (res.ok) {
    return c.redirect("http://127.0.0.1:3000/admin/settings?line=ok", 307)
  }
  return c.redirect("http://127.0.0.1:3000/admin/settings?line=error_token", 307)
})
app.post("/admin/integrations/line/callback", async (c) => {
  const env = c.env
  const body = await c.req.json<{
    code: string
    state?: string
    tenantId?: string
  }>()

  const tenantId = body.tenantId || getTenantId(c.req.raw)
  const code = body.code

  if (!code) {
    return c.json({ ok: false, error: "missing_code" }, 400)
  }

  const tokenUrl = "https://api.line.me/oauth2/v2.1/token"

  // auth-url で使った redirect_uri と完全一致させる
  const redirectBase = env.LINE_LOGIN_REDIRECT_BASE ?? "http://localhost:3000"
  const redirectUri = `${redirectBase.replace(/\/$/, "")}/admin/integrations/line/callback`

  const clientId =
  (env.LINE_CLIENT_ID ?? "").trim() ||
  (env.LINE_LOGIN_CLIENT_ID ?? "").trim() ||
  (env.LINE_LOGIN_CHANNEL_ID ?? "").trim();

const clientSecret =
  (env.LINE_CLIENT_SECRET ?? "").trim() ||
  (env.LINE_LOGIN_CHANNEL_SECRET ?? "").trim();

if (!clientId) {
  return c.json({ ok: false, error: "LINE_CLIENT_ID is not configured" }, 500);
}
if (!clientSecret) {
  return c.json({ ok: false, error: "LINE_CLIENT_SECRET is not configured" }, 500);
}

console.log("[LINE][token] clientId.len=", clientId.length, "redirectUri=", redirectUri);

console.log("[LINE OAuth][token] clientId.len=", clientId.length, "clientSecret.len=", clientSecret.length, "redirectUri=", redirectUri);
const tokenBody = new URLSearchParams({
  grant_type: "authorization_code",
  code,
  redirect_uri: redirectUri,
  client_id: clientId,
  client_secret: clientSecret,
});
const tokenRes = await fetch(tokenUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      "Accept": "application/json",
    },
    body: tokenBody.toString(),
  })
  
  
  const tokenTxt = await tokenRes.clone().text()
  console.log("[LINE OAuth][token] status=", tokenRes.status, "body=", tokenTxt)

  // ✅ IMPORTANT: read tokenRes body ONLY ONCE
  const raw = await tokenRes.text()

  if (!tokenRes.ok) {
    console.error("[LINE][token] status=", tokenRes.status)
    console.error("[LINE][token] raw=", raw.slice(0, 800))
    return c.json({ ok: false, error: "token_request_failed", status: tokenRes.status, detail: raw }, 500)
  }

  let tokenJson: any
  try {
    tokenJson = JSON.parse(raw)
  } catch {
    console.error("[LINE][token] parse_failed raw=", raw.slice(0, 800))
    return c.json({ ok: false, error: "token_parse_failed", detail: raw }, 500)
  }

  if (!tokenJson?.access_token) {
    console.error("[LINE][token] missing_access_token json=", tokenJson)
    return c.json({ ok: false, error: "token_missing_access_token", detail: tokenJson }, 500)
  }

  if (!tokenJson.id_token) {
    return c.json({ ok: false, error: "missing_id_token" }, 500)
  }

  const verifyBody = new URLSearchParams({
    id_token: tokenJson.id_token,
    client_id: clientId,
  })

  const verifyRes = await fetch("https://api.line.me/oauth2/v2.1/verify", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: verifyBody.toString(),
  })

  if (!verifyRes.ok) {
    const text = await verifyRes.text()
    console.error("[LINE][verify] error", verifyRes.status, text)
    return c.json({ ok: false, error: "verify_failed" }, 500)
  }

  const v = (await verifyRes.json()) as any
  console.log("[LINE OAuth][verify] json=", JSON.stringify(v).slice(0, 800))

  const userId = (v?.sub ?? v?.userId ?? v?.user_id ?? "").toString().trim()
  const displayName = (v?.name ?? v?.displayName ?? "LINE User").toString()
  const pictureUrl = (v?.picture ?? v?.pictureUrl ?? v?.picture_url ?? undefined) as string | undefined

  if (!userId) {
    console.error("[LINE OAuth][verify] missing userId. json=", v)
    return c.json({ ok: false, error: "verify_missing_userid", detail: v }, 500)
  }

  const db = c.env.DB
  const now = new Date().toISOString()
  console.log("[LINE OAuth][upsert] userId=", userId, "name=", displayName)


