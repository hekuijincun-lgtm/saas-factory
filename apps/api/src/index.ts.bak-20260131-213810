export { SlotLock };
import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { SlotLock } from './durable/SlotLock';
import { DEFAULT_ADMIN_SETTINGS, validateAdminSettings, mergeSettings, type AdminSettings } from './settings';
import { getBusinessHoursForDate, generateSlots, getTodayJST, isWorkingTime, timeToMinutes, getNowMinutesJST } from './slotUtils';
import { buildLineAuthUrl, exchangeCodeForToken, verifyAccessToken, sendLineMessage, sendLineNotification, verifyLineWebhookSignature } from './integrations/line';
import { getLineConfig, saveLineConfig, deleteLineConfig, hasLineConfig, logAudit, getMaskedConfig, type LineConfigPlain } from './lineConfig';
import { getLineConfigOrNull, getLineConfigRequired, jsonError } from './line/config';
import { getLineConfigOrNull, getLineConfigRequired, jsonError } from './line/config';

type Env = {
  ENVIRONMENT?: string;
  VERSION?: string;
  SAAS_FACTORY: KVNamespace;
  SLOT_LOCK: DurableObjectNamespace<SlotLock>;
  DB: D1Database;
  CONFIG_ENC_KEY?: string; // æš—å·åŒ–ãƒã‚¹ã‚¿ãƒ¼ã‚­ãƒ¼ï¼ˆbase64 32byteï¼‰
  LINE_CLIENT_ID?: string; // LINE Login Client ID
  LINE_LOGIN_CHANNEL_ID?: string; // LINE Login Channel ID
  LINE_LOGIN_CHANNEL_SECRET?: string; // LINE Login Channel Secret
  LINE_LOGIN_REDIRECT_BASE?: string; // LINE Login Redirect Base URL (ä¾‹: http://localhost:3000)
  LINE_REDIRECT_URI?: string; // LINE OAuth Redirect URI (ä¾‹: http://localhost:3000/admin/integrations/line/callback)
  LINE_CHANNEL_ACCESS_TOKEN?: string; // å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼ˆD1ç§»è¡Œå¾Œã¯å‰Šé™¤äºˆå®šï¼‰
  LINE_CHANNEL_SECRET?: string; // å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼ˆD1ç§»è¡Œå¾Œã¯å‰Šé™¤äºˆå®šï¼‰
  WEB_BASE_URL?: string; // ä¾‹: http://localhost:3000
};

const app = new Hono<{ Bindings: Env }>();

/**
 * ãƒ†ãƒŠãƒ³ãƒˆIDã‚’å–å¾—ï¼ˆæš«å®š: 1ãƒ†ãƒŠãƒ³ãƒˆã®ã¿å¯¾å¿œï¼‰
 * å°†æ¥çš„ã«ã¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ˜ãƒƒãƒ€ãƒ¼ã‚„ã‚µãƒ–ãƒ‰ãƒ¡ã‚¤ãƒ³ã‹ã‚‰å–å¾—ã™ã‚‹
 */
function getTenantId(c: { req: { header: (name: string) => string | undefined } }): string {
  // TODO: ãƒãƒ«ãƒãƒ†ãƒŠãƒ³ãƒˆå¯¾å¿œæ™‚ã«å®Ÿè£…
  // const tenantId = c.req.header('X-Tenant-ID') || extractFromSubdomain(c.req.url);
  return 'default';
}

// CORSè¨­å®š: é–‹ç™ºæ™‚ã®ã¿ http://localhost:3000 ã‚’è¨±å¯
app.use('/*', cors({
  origin: (origin, c) => {
    const env = c.env?.ENVIRONMENT || 'development';
    // é–‹ç™ºç’°å¢ƒã®å ´åˆã®ã¿CORSã‚’è¨±å¯
    if (env === 'development' && origin === 'http://localhost:3000') {
      return origin;
    }
    // æœ¬ç•ªç’°å¢ƒã¾ãŸã¯è¨±å¯ã•ã‚Œã¦ã„ãªã„Originã®å ´åˆã¯CORSã‚’ä»˜ã‘ãªã„
    return null;
  },
  allowMethods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
  allowHeaders: ['Content-Type', 'Authorization'],
  credentials: true,
}));

// GET /ping (ä¾å­˜ã‚¼ãƒ­ã®ç–é€šç¢ºèªãƒ«ãƒ¼ãƒˆ)
app.get('/ping', (c) => c.text('pong'));

// GET /
app.get('/', (c) => {
  return c.text('API Online');
});

// GET /health
app.get('/health', (c) => {
  const env = c.env;
  return c.json({
    ok: true,
    ts: new Date().toISOString(),
    env: env.ENVIRONMENT || 'development',
    version: env.VERSION || '1.0.0',
  });
});

// GET /meta
app.get('/meta', (c) => {
  const env = c.env;
  return c.json({
    service: 'saas-factory-api',
    env: env.ENVIRONMENT || 'development',
    version: env.VERSION || '1.0.0',
    runtime: 'cloudflare-workers',
  });
});

// GET /slots?date=YYYY-MM-DD&staffId=xxx(optional)
app.get('/slots', async (c) => {
  const dateStr = c.req.query('date');
  const staffId = c.req.query('staffId'); // optional
  const debug = c.req.query('debug');
  
  // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰: debug=1 ã§ä¾å­˜ã‚¼ãƒ­ã§å³ return
  if (debug === '1') {
    return c.json({ ok: true, stage: 'entered', date: dateStr, staffId: staffId || null });
  }
  
  // date ãŒãªã„/ä¸æ­£ãªã‚‰ 400
  if (!dateStr) {
    return c.json({ ok: false, error: 'invalid date' }, 400);
  }
  
  // æ—¥ä»˜å½¢å¼ã®æ¤œè¨¼ (YYYY-MM-DD)
  const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
  if (!dateRegex.test(dateStr)) {
    return c.json({ ok: false, error: 'invalid date' }, 400);
  }
  
  // æ—¥ä»˜ãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
  const date = new Date(dateStr + 'T00:00:00+09:00'); // JSTã¨ã—ã¦è§£é‡ˆ
  if (isNaN(date.getTime())) {
    return c.json({ ok: false, error: 'invalid date' }, 400);
  }
  
  const kv = c.env.SAAS_FACTORY;
  
  // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰: debug=2 ã§ settings ã‚’å–å¾—
  if (debug === '2') {
    try {
      const settingsValue = await kv.get('settings:default');
      const hasSettings = !!settingsValue;
      return c.json({ 
        ok: true, 
        stage: 'settings_fetched', 
        date: dateStr,
        hasSettings,
        settingsLength: settingsValue?.length || 0
      });
    } catch (e) {
      return c.json({ 
        ok: false, 
        stage: 'settings_error', 
        error: e instanceof Error ? e.message : String(e) 
      }, 500);
    }
  }
  
  // è¨­å®šã‚’å–å¾—
  const settingsValue = await kv.get('settings:default');
  const settings: AdminSettings = settingsValue
    ? mergeSettings(DEFAULT_ADMIN_SETTINGS, JSON.parse(settingsValue))
    : DEFAULT_ADMIN_SETTINGS;
  
  // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰: debug=3 ã§ shift ã‚’èª­ã‚€
  if (debug === '3') {
    try {
      let shiftPresent = false;
      let staffListPresent = false;
      
      if (staffId) {
        const shiftValue = await kv.get(`shift:${staffId}`);
        shiftPresent = !!shiftValue;
      }
      
      // staff list ã‚‚ç¢ºèª
      const staffListValue = await kv.get('staff:list');
      staffListPresent = !!staffListValue;
      
      return c.json({ 
        ok: true, 
        stage: 'shift_fetched', 
        date: dateStr,
        staffId: staffId || null,
        shiftPresent,
        staffListPresent
      });
    } catch (e) {
      return c.json({ 
        ok: false, 
        stage: 'error', 
        error: e instanceof Error ? e.message : String(e) 
      }, 500);
    }
  }
  
  // å–¶æ¥­æ™‚é–“ã‚’å–å¾—ï¼ˆå®šä¼‘æ—¥ãƒ»ä¾‹å¤–æ—¥ã‚’è€ƒæ…®ï¼‰
  const businessHours = getBusinessHoursForDate(dateStr, settings);
  
  if (!businessHours) {
    // ä¼‘æ¥­æ—¥ã¾ãŸã¯å®šä¼‘æ—¥
    return c.json({
      ok: true,
      date: dateStr,
      slots: [],
    });
  }
  
  // ã‚¹ãƒ­ãƒƒãƒˆé–“éš”ã‚’å–å¾—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ30åˆ†ï¼‰
  const slotIntervalMin = settings.businessHours.slotIntervalMin || 30;
  
  // staffId ãŒã‚ã‚‹å ´åˆã€ãã®ã‚¹ã‚¿ãƒƒãƒ•ã®ã‚·ãƒ•ãƒˆã‚’å–å¾—
  let staffShift: StaffShift | null = null;
  if (staffId) {
    try {
      const shiftValue = await kv.get(`shift:${staffId}`);
      if (shiftValue) {
        staffShift = JSON.parse(shiftValue) as StaffShift;
      }
    } catch (e) {
      console.warn(`Failed to load shift for staff ${staffId}:`, e);
    }
  }
  
  // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰: debug=4 ã§äºˆç´„æ¸ˆã¿ã‚­ãƒ¼ã®å‚ç…§ã¾ã§
  if (debug === '4') {
    try {
      // æœ€åˆã®ã‚¹ãƒ­ãƒƒãƒˆã®äºˆç´„ã‚­ãƒ¼ã‚’å‚ç…§ï¼ˆã‚¹ãƒ­ãƒƒãƒˆç”Ÿæˆã¯ã—ãªã„ï¼‰
      // ä»®ã®æ™‚é–“ã§ã‚­ãƒ¼ã‚’æ§‹ç¯‰ã—ã¦å‚ç…§ã™ã‚‹ã ã‘
      const testKey = `rsv:${dateStr}:10:00`;
      const existing = await kv.get(testKey);
      const reservedPresent = !!existing;
      return c.json({ 
        ok: true, 
        stage: 'reserved_key_checked', 
        date: dateStr,
        testKey,
        reservedPresent
      });
    } catch (e) {
      return c.json({ 
        ok: false, 
        stage: 'error', 
        error: e instanceof Error ? e.message : String(e) 
      }, 500);
    }
  }
  
  // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰: debug=5 ã§ã‚¹ãƒ­ãƒƒãƒˆç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ç›´å‰ã¾ã§
  if (debug === '5') {
    return c.json({ 
      ok: true, 
      stage: 'before_slot_generation', 
      date: dateStr,
      hasBusinessHours: !!businessHours,
      slotIntervalMin,
      hasShift: !!staffShift,
      staffId: staffId || null
    });
  }
  
  // ã‚¹ãƒ­ãƒƒãƒˆã‚’ç”Ÿæˆ
  const timeSlots = generateSlots(businessHours.openTime, businessHours.closeTime, slotIntervalMin);
  
  // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰: debug=6 ã§ã‚¹ãƒ­ãƒƒãƒˆç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè¡Œã—ã¦ stage=done ã§è¿”ã™
  if (debug === '6') {
    try {
      // ç„¡é™ãƒ«ãƒ¼ãƒ—æ¤œçŸ¥: maxIterations ã‚¬ãƒ¼ãƒ‰
      const maxIterations = 5000;
      let iterationCount = 0;
      
      // ã‚¹ãƒ­ãƒƒãƒˆç”Ÿæˆå¾Œã®å‡¦ç†ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆï¼ˆæœ€åˆã®æ•°å€‹ã ã‘ï¼‰
      const sampleSlots = timeSlots.slice(0, Math.min(5, timeSlots.length));
      const sampleResults = await Promise.all(
        sampleSlots.map(async (time) => {
          iterationCount++;
          if (iterationCount > maxIterations) {
            throw new Error(`Max iterations (${maxIterations}) exceeded`);
          }
          
          const key = `rsv:${dateStr}:${time}`;
          const existing = await kv.get(key);
          return {
            time,
            key,
            reserved: !!existing
          };
        })
      );
      
      return c.json({ 
        ok: true, 
        stage: 'done', 
        date: dateStr,
        totalSlots: timeSlots.length,
        sampleSlots: sampleResults.length,
        iterationCount,
        firstSlot: timeSlots[0] || null,
        lastSlot: timeSlots[timeSlots.length - 1] || null
      });
    } catch (e) {
      return c.json({ 
        ok: false, 
        stage: 'error', 
        error: e instanceof Error ? e.message : String(e) 
      }, 500);
    }
  }
  
  // KVã‹ã‚‰äºˆç´„æ¸ˆã¿ã‚¹ãƒ­ãƒƒãƒˆã‚’ç¢ºèªã—ã€cutoffMinutesã¨shiftã‚’é©ç”¨
  // reason ã®å„ªå…ˆé †ä½: 1) reserved, 2) cutoff, 3) closed, 4) shift
  // ç„¡é™ãƒ«ãƒ¼ãƒ—æ¤œçŸ¥: maxIterations ã‚¬ãƒ¼ãƒ‰
  const maxIterations = 5000;
  let iterationCount = 0;
  
  const slots = await Promise.all(
    timeSlots.map(async (time) => {
      iterationCount++;
      if (iterationCount > maxIterations) {
        throw new Error(`Max iterations (${maxIterations}) exceeded in slot processing`);
      }
      // ç†ç”±ã‚’å„ªå…ˆé †ä½ã§åˆ¤å®š
      const reasons: string[] = [];
      
      // 1. closed ãƒã‚§ãƒƒã‚¯ï¼ˆå–¶æ¥­æ™‚é–“å¤–ï¼‰
      if (!businessHours) {
        reasons.push('closed');
      }
      
      // 2. reserved ãƒã‚§ãƒƒã‚¯ï¼ˆäºˆç´„æ¸ˆã¿ã€ã‹ã¤statusãŒactiveï¼‰
      const key = `rsv:${dateStr}:${time}`;
      const existing = await kv.get(key);
      if (existing) {
        try {
          const reservation = JSON.parse(existing);
          // statusãŒ"canceled"ã§ãªã„å ´åˆã®ã¿äºˆç´„æ¸ˆã¿ã¨ã¿ãªã™
          if (reservation.status !== 'canceled') {
            reasons.push('reserved');
          }
        } catch (e) {
          // ãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
        }
      }
      
      // 3. cutoff ãƒã‚§ãƒƒã‚¯ï¼ˆå½“æ—¥ã‹ã¤cutoffMinutesä»¥å†…ï¼‰
      const today = getTodayJST();
      if (dateStr === today) {
        const nowMin = getNowMinutesJST();
        const slotMin = timeToMinutes(time);
        const diffMinutes = slotMin - nowMin;
        if (diffMinutes < settings.rules.cutoffMinutes) {
          reasons.push('cutoff');
        }
      }
      
      // 4. shift ãƒã‚§ãƒƒã‚¯ï¼ˆstaffIdãŒã‚ã‚‹å ´åˆã€å‹¤å‹™æ™‚é–“å¤–ï¼‰
      if (staffId && staffShift) {
        const isWorking = isWorkingTime(dateStr, time, staffShift);
        if (!isWorking) {
          reasons.push('shift');
        }
      }
      
      // å„ªå…ˆé †ä½ã§æœ€åˆã®reasonã‚’æ¡ç”¨: reserved > cutoff > closed > shift
      const reasonPriority: Record<string, number> = {
        reserved: 1,
        cutoff: 2,
        closed: 3,
        shift: 4,
      };
      
      let finalReason: string | undefined = undefined;
      if (reasons.length > 0) {
        reasons.sort((a, b) => (reasonPriority[a] || 999) - (reasonPriority[b] || 999));
        finalReason = reasons[0];
      }
      
      // availableåˆ¤å®š: ã„ãšã‚Œã‹ã®ç†ç”±ãŒã‚ã‚Œã°false
      const available = finalReason === undefined;
      
      return {
        time,
        available,
        ...(finalReason ? { reason: finalReason as 'cutoff' | 'reserved' | 'shift' | 'closed' } : {}),
      };
    })
  );
  
  return c.json({
    ok: true,
    date: dateStr,
    ...(staffId ? { staffId } : {}),
    slots,
  });
});

// POST /reserve
app.post('/reserve', async (c) => {
  try {
    const body = await c.req.json();
    const { date, time, name, phone } = body;
    
    // validation: date/time/name å¿…é ˆã€‚phoneã¯ä»»æ„
    if (!date || typeof date !== 'string') {
      return c.json({ ok: false, error: 'date is required' }, 400);
    }
    if (!time || typeof time !== 'string') {
      return c.json({ ok: false, error: 'time is required' }, 400);
    }
    if (!name || typeof name !== 'string' || name.trim() === '') {
      return c.json({ ok: false, error: 'name is required' }, 400);
    }
    
    // Durable ObjectçµŒç”±ã§å‡¦ç†ï¼ˆãƒ­ãƒƒã‚¯ã‚­ãƒ¼: ${date}:${time}ï¼‰
    const lockKey = `${date}:${time}`;
    const id = c.env.SLOT_LOCK.idFromName(lockKey);
    const stub = c.env.SLOT_LOCK.get(id);
    
    // Durable Objectã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è»¢é€
    // Durable Objectã¯åŒä¸€IDã«å¯¾ã—ã¦åŒæ™‚ã«1ã¤ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã—ã‹å‡¦ç†ã—ãªã„ãŸã‚ã€
    // è‡ªç„¶ã«ãƒ­ãƒƒã‚¯ãŒã‹ã‹ã‚Šã€äºŒé‡äºˆç´„ã‚’é˜²ã
    const doRequest = new Request('http://slot-lock/reserve', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
    });
    
    const response = await stub.fetch(doRequest);
    const result = await response.json();
    const status = response.status;
    
    // äºˆç´„ä½œæˆæˆåŠŸæ™‚ã«LINEé€šçŸ¥ã‚’é€ä¿¡ï¼ˆéåŒæœŸã€ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ï¼‰
    if (status === 200 && result.ok) {
      try {
        const kv = c.env.SAAS_FACTORY;
        const tenantId = getTenantId(c);
        
        // settings ã‚’å–å¾—ã—ã¦é€šçŸ¥ãƒ«ãƒ¼ãƒ«ã‚’ç¢ºèª
        const settingsValue = await kv.get('settings:default');
        const settings: AdminSettings = settingsValue
          ? mergeSettings(DEFAULT_ADMIN_SETTINGS, JSON.parse(settingsValue))
          : DEFAULT_ADMIN_SETTINGS;
        
        // é€šçŸ¥ãŒæœ‰åŠ¹ã§ã€LINEé€£æºæ¸ˆã¿ã®å ´åˆã®ã¿é€ä¿¡
        if (settings.integrations?.line?.connected && settings.integrations.line.notifyOnReservation !== false) {
          const { date, time, name, reservationId, staffId } = result;
          
          // ã‚¹ã‚¿ãƒƒãƒ•åã‚’å–å¾—ï¼ˆã‚ã‚Œã°ï¼‰
          let staffName = 'æŒ‡åãªã—';
          if (staffId) {
            try {
              const staffValue = await kv.get(`staff:${staffId}`);
              if (staffValue) {
                const staff = JSON.parse(staffValue);
                staffName = staff.name || staffId;
              }
            } catch (e) {
              // ã‚¹ã‚¿ãƒƒãƒ•å–å¾—å¤±æ•—ã¯ç„¡è¦–
            }
          }
          
          // ãƒ¡ãƒ‹ãƒ¥ãƒ¼æƒ…å ±ã‚’å–å¾—ï¼ˆã‚ã‚Œã°ã€bodyã«menuIdãŒã‚ã‚Œã°ï¼‰
          let menuName = 'ãƒ¡ãƒ‹ãƒ¥ãƒ¼æœªæŒ‡å®š';
          if (body.menuId) {
            try {
              const menuValue = await kv.get(`menu:${body.menuId}`);
              if (menuValue) {
                const menu = JSON.parse(menuValue);
                menuName = menu.name || body.menuId;
              }
            } catch (e) {
              // ãƒ¡ãƒ‹ãƒ¥ãƒ¼å–å¾—å¤±æ•—ã¯ç„¡è¦–
            }
          }
          
          const message = `äºˆç´„ãŒç¢ºå®šã—ã¾ã—ãŸ âœ…\næ—¥æ™‚: ${date} ${time}\nãƒ¡ãƒ‹ãƒ¥ãƒ¼: ${menuName}\nã‚¹ã‚¿ãƒƒãƒ•: ${staffName}\näºˆç´„ID: ${reservationId}`;
          
          // éåŒæœŸã§é€šçŸ¥ã‚’é€ä¿¡ï¼ˆã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ï¼‰
          // D1ã‹ã‚‰è¨­å®šã‚’å–å¾—ï¼ˆãªã‘ã‚Œã°ç’°å¢ƒå¤‰æ•°ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
          getLineConfigOrNull({ DB: c.env.DB, CONFIG_ENC_KEY: c.env.CONFIG_ENC_KEY }, tenantId).then(async (config) => {
            let channelAccessToken: string | undefined;
            if (config) {
              channelAccessToken = config.channelAccessToken;
            } else {
              channelAccessToken = c.env.LINE_CHANNEL_ACCESS_TOKEN;
            }
            const userId = settings.integrations.line.userId;
            if (channelAccessToken && userId) {
              sendLineNotification(kv, channelAccessToken, userId, message)
              .then(async () => {
                // æˆåŠŸæ™‚: lastSentAt ã‚’è¨˜éŒ²
                const lastSentAtKey = `line:notify:lastSentAt:${tenantId}`;
                await kv.put(lastSentAtKey, JSON.stringify({
                  message,
                  at: Date.now(),
                }));
              })
              .catch(async (err) => {
                // ã‚¨ãƒ©ãƒ¼æ™‚: lastError ã‚’è¨˜éŒ²ï¼ˆç§˜å¯†å€¤ã¯ãƒ­ã‚°ã«å‡ºåŠ›ã—ãªã„ï¼‰
                const errorMessage = err instanceof Error ? err.message : String(err);
                // console.error ã¯ç§˜å¯†å€¤ã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ä½¿ç”¨ã—ãªã„
                const lastErrorKey = `line:notify:lastError:${tenantId}`;
                await kv.put(lastErrorKey, JSON.stringify({
                  message,
                  error: errorMessage,
                  at: Date.now(),
                }));
              });
            }
          }).catch(() => {
            // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
          });
        }
      } catch (err) {
        // é€šçŸ¥é€ä¿¡å¤±æ•—ã¯ç„¡è¦–ï¼ˆäºˆç´„ä½œæˆã¯æˆåŠŸã—ã¦ã„ã‚‹ãŸã‚ï¼‰
        // console.error ã¯ç§˜å¯†å€¤ã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ä½¿ç”¨ã—ãªã„
      }
    }
    
    return c.json(result, status);
  } catch (error) {
    return c.json({ ok: false, error: 'Invalid request body' }, 400);
  }
});

// GET /admin/reservations?date=YYYY-MM-DD
app.get('/admin/reservations', async (c) => {
  const dateStr = c.req.query('date');
  
  // date ãŒãªã„/ä¸æ­£ãªã‚‰ 400
  if (!dateStr) {
    return c.json({ ok: false, error: 'date parameter is required' }, 400);
  }
  
  // æ—¥ä»˜å½¢å¼ã®æ¤œè¨¼ (YYYY-MM-DD)
  const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
  if (!dateRegex.test(dateStr)) {
    return c.json({ ok: false, error: 'invalid date format' }, 400);
  }
  
  // æ—¥ä»˜ãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
  const date = new Date(dateStr + 'T00:00:00');
  if (isNaN(date.getTime())) {
    return c.json({ ok: false, error: 'invalid date' }, 400);
  }
  
  const kv = c.env.SAAS_FACTORY;
  const prefix = `rsv:${dateStr}:`;
  
  // KVã‹ã‚‰æŒ‡å®šæ—¥ä»˜ã®äºˆç´„ã‚’å–å¾—ï¼ˆprefix scanï¼‰
  // æ³¨æ„: Cloudflare KVã¯prefix scanã‚’ç›´æ¥ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ãŸã‚ã€
  // å…¨ã‚­ãƒ¼ã‚’ãƒªã‚¹ãƒˆã—ã¦ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
  // ç°¡æ˜“å®Ÿè£…ã¨ã—ã¦ã€å›ºå®šæ™‚é–“å¸¯ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã™ã‚‹æ–¹æ³•ã‚’ä½¿ç”¨
  const timeSlots = ['10:00', '11:00', '12:00', '13:00', '14:00', '15:00', '16:00', '17:00', '18:00'];
  const reservations = [];
  
  for (const time of timeSlots) {
    const key = `${prefix}${time}`;
    const value = await kv.get(key);
    if (value) {
      try {
        const reservation = JSON.parse(value);
        reservations.push(reservation);
      } catch (e) {
        // ãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
      }
    }
  }
  
  return c.json({
    ok: true,
    date: dateStr,
    reservations,
  });
});

// GET /admin/staff
app.get('/admin/staff', async (c) => {
  try {
    const kv = c.env.SAAS_FACTORY;
    const value = await kv.get('admin:staff:list');
    
    if (value) {
      const staff = JSON.parse(value);
      return c.json({ ok: true, data: staff });
    }
    
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‡ãƒ¼ã‚¿
    const defaultStaff = [
      { id: 'sakura', name: 'ã‚µã‚¯ãƒ©', role: 'Top Stylist', active: true, sortOrder: 1 },
      { id: 'kenji', name: 'ã‚±ãƒ³ã‚¸', role: 'Director', active: true, sortOrder: 2 },
      { id: 'rookie', name: 'Rookie', role: 'Staff', active: true, sortOrder: 3 },
    ];
    
    return c.json({ ok: true, data: defaultStaff });
  } catch (error) {
    return c.json({ ok: false, error: 'Failed to fetch staff', message: String(error) }, 500);
  }
});

// POST /admin/staff
app.post('/admin/staff', async (c) => {
  try {
    const body = await c.req.json();
    const { name, role, active, sortOrder } = body;
    
    // validation
    if (!name || typeof name !== 'string' || name.trim() === '') {
      return c.json({ ok: false, error: 'name is required' }, 400);
    }
    if (active !== undefined && typeof active !== 'boolean') {
      return c.json({ ok: false, error: 'active must be boolean' }, 400);
    }
    if (sortOrder !== undefined && (typeof sortOrder !== 'number' || sortOrder < 0)) {
      return c.json({ ok: false, error: 'sortOrder must be non-negative number' }, 400);
    }
    
    const kv = c.env.SAAS_FACTORY;
    const value = await kv.get('admin:staff:list');
    const staff = value ? JSON.parse(value) : [];
    
    // IDç”Ÿæˆ
    const id = `staff_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
    const newStaff = {
      id,
      name: name.trim(),
      role: role?.trim() || undefined,
      active: active !== undefined ? active : true,
      sortOrder: sortOrder !== undefined ? sortOrder : staff.length,
    };
    
    staff.push(newStaff);
    await kv.put('admin:staff:list', JSON.stringify(staff));
    
    return c.json({ ok: true, data: newStaff }, 201);
  } catch (error) {
    return c.json({ ok: false, error: 'Failed to create staff', message: String(error) }, 500);
  }
});

// PATCH /admin/staff/:id
app.patch('/admin/staff/:id', async (c) => {
  try {
    const id = c.req.param('id');
    const body = await c.req.json();
    const { name, role, active, sortOrder } = body;
    
    const kv = c.env.SAAS_FACTORY;
    const value = await kv.get('admin:staff:list');
    if (!value) {
      return c.json({ ok: false, error: 'Staff not found' }, 404);
    }
    
    const staff = JSON.parse(value);
    const index = staff.findIndex((s: any) => s.id === id);
    if (index === -1) {
      return c.json({ ok: false, error: 'Staff not found' }, 404);
    }
    
    // æ›´æ–°
    if (name !== undefined) {
      if (typeof name !== 'string' || name.trim() === '') {
        return c.json({ ok: false, error: 'name must be non-empty string' }, 400);
      }
      staff[index].name = name.trim();
    }
    if (role !== undefined) {
      staff[index].role = role === null || role === '' ? undefined : role.trim();
    }
    if (active !== undefined) {
      if (typeof active !== 'boolean') {
        return c.json({ ok: false, error: 'active must be boolean' }, 400);
      }
      staff[index].active = active;
    }
    if (sortOrder !== undefined) {
      if (typeof sortOrder !== 'number' || sortOrder < 0) {
        return c.json({ ok: false, error: 'sortOrder must be non-negative number' }, 400);
      }
      staff[index].sortOrder = sortOrder;
    }
    
    await kv.put('admin:staff:list', JSON.stringify(staff));
    
    return c.json({ ok: true, data: staff[index] });
  } catch (error) {
    return c.json({ ok: false, error: 'Failed to update staff', message: String(error) }, 500);
  }
});

// GET /admin/menu
app.get('/admin/menu', async (c) => {
  try {
    const kv = c.env.SAAS_FACTORY;
    const value = await kv.get('admin:menu:list');
    
    if (value) {
      const menu = JSON.parse(value);
      return c.json({ ok: true, data: menu });
    }
    
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‡ãƒ¼ã‚¿
    const defaultMenu = [
      { id: 'cut', name: 'ã‚«ãƒƒãƒˆ', price: 5000, durationMin: 60, active: true, sortOrder: 1 },
      { id: 'color', name: 'ã‚«ãƒ©ãƒ¼', price: 8000, durationMin: 90, active: true, sortOrder: 2 },
      { id: 'perm', name: 'ãƒ‘ãƒ¼ãƒ', price: 10000, durationMin: 120, active: true, sortOrder: 3 },
    ];
    
    return c.json({ ok: true, data: defaultMenu });
  } catch (error) {
    return c.json({ ok: false, error: 'Failed to fetch menu', message: String(error) }, 500);
  }
});

// POST /admin/menu
app.post('/admin/menu', async (c) => {
  try {
    const body = await c.req.json();
    const { name, price, durationMin, active, sortOrder } = body;
    
    // validation
    if (!name || typeof name !== 'string' || name.trim() === '') {
      return c.json({ ok: false, error: 'name is required' }, 400);
    }
    if (price === undefined || typeof price !== 'number' || price < 0) {
      return c.json({ ok: false, error: 'price must be non-negative number' }, 400);
    }
    if (durationMin === undefined || typeof durationMin !== 'number' || durationMin <= 0) {
      return c.json({ ok: false, error: 'durationMin must be positive number' }, 400);
    }
    if (active !== undefined && typeof active !== 'boolean') {
      return c.json({ ok: false, error: 'active must be boolean' }, 400);
    }
    if (sortOrder !== undefined && (typeof sortOrder !== 'number' || sortOrder < 0)) {
      return c.json({ ok: false, error: 'sortOrder must be non-negative number' }, 400);
    }
    
    const kv = c.env.SAAS_FACTORY;
    const value = await kv.get('admin:menu:list');
    const menu = value ? JSON.parse(value) : [];
    
    // IDç”Ÿæˆ
    const id = `menu_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
    const newMenuItem = {
      id,
      name: name.trim(),
      price,
      durationMin,
      active: active !== undefined ? active : true,
      sortOrder: sortOrder !== undefined ? sortOrder : menu.length,
    };
    
    menu.push(newMenuItem);
    await kv.put('admin:menu:list', JSON.stringify(menu));
    
    return c.json({ ok: true, data: newMenuItem }, 201);
  } catch (error) {
    return c.json({ ok: false, error: 'Failed to create menu', message: String(error) }, 500);
  }
});

// PATCH /admin/menu/:id
app.patch('/admin/menu/:id', async (c) => {
  try {
    const id = c.req.param('id');
    const body = await c.req.json();
    const { name, price, durationMin, active, sortOrder } = body;
    
    const kv = c.env.SAAS_FACTORY;
    const value = await kv.get('admin:menu:list');
    if (!value) {
      return c.json({ ok: false, error: 'Menu not found' }, 404);
    }
    
    const menu = JSON.parse(value);
    const index = menu.findIndex((m: any) => m.id === id);
    if (index === -1) {
      return c.json({ ok: false, error: 'Menu not found' }, 404);
    }
    
    // æ›´æ–°
    if (name !== undefined) {
      if (typeof name !== 'string' || name.trim() === '') {
        return c.json({ ok: false, error: 'name must be non-empty string' }, 400);
      }
      menu[index].name = name.trim();
    }
    if (price !== undefined) {
      if (typeof price !== 'number' || price < 0) {
        return c.json({ ok: false, error: 'price must be non-negative number' }, 400);
      }
      menu[index].price = price;
    }
    if (durationMin !== undefined) {
      if (typeof durationMin !== 'number' || durationMin <= 0) {
        return c.json({ ok: false, error: 'durationMin must be positive number' }, 400);
      }
      menu[index].durationMin = durationMin;
    }
    if (active !== undefined) {
      if (typeof active !== 'boolean') {
        return c.json({ ok: false, error: 'active must be boolean' }, 400);
      }
      menu[index].active = active;
    }
    if (sortOrder !== undefined) {
      if (typeof sortOrder !== 'number' || sortOrder < 0) {
        return c.json({ ok: false, error: 'sortOrder must be non-negative number' }, 400);
      }
      menu[index].sortOrder = sortOrder;
    }
    
    await kv.put('admin:menu:list', JSON.stringify(menu));
    
    return c.json({ ok: true, data: menu[index] });
  } catch (error) {
    return c.json({ ok: false, error: 'Failed to update menu', message: String(error) }, 500);
  }
});

// GET /admin/settings
app.get('/admin/settings', async (c) => {
  try {
    const kv = c.env.SAAS_FACTORY;
    const value = await kv.get('settings:default');
    
    if (value) {
      const partial = JSON.parse(value) as Partial<AdminSettings>;
      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§ãƒãƒ¼ã‚¸ã—ã¦å®Œå…¨ãªè¨­å®šã‚’è¿”ã™
      const settings = mergeSettings(DEFAULT_ADMIN_SETTINGS, partial);
      return c.json({ ok: true, data: settings });
    }
    
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’è¿”ã™
    return c.json({ ok: true, data: DEFAULT_ADMIN_SETTINGS });
  } catch (error) {
    return c.json({ ok: false, error: 'Failed to fetch settings', message: String(error) }, 500);
  }
});

// PUT /admin/settings
app.put('/admin/settings', async (c) => {
  try {
    const body = await c.req.json() as Partial<AdminSettings>;
    
    // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    const validation = validateAdminSettings(body);
    if (!validation.valid) {
      return c.json({ ok: false, error: validation.error }, 400);
    }
    
    const kv = c.env.SAAS_FACTORY;
    const existingValue = await kv.get('settings:default');
    const existing = existingValue ? (JSON.parse(existingValue) as Partial<AdminSettings>) : {};
    
    // æ—¢å­˜è¨­å®šã¨ãƒãƒ¼ã‚¸ï¼ˆPUTã¯å…¨ç½®æ›ã ãŒã€æ¬ æãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§è£œå®Œï¼‰
    const merged = mergeSettings(DEFAULT_ADMIN_SETTINGS, { ...existing, ...body });
    
    // å†åº¦ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå®Œå…¨ãªè¨­å®šã«å¯¾ã—ã¦ï¼‰
    const fullValidation = validateAdminSettings(merged);
    if (!fullValidation.valid) {
      return c.json({ ok: false, error: fullValidation.error }, 400);
    }
    
    // KVã«ä¿å­˜
    await kv.put('settings:default', JSON.stringify(merged));
    
    return c.json({ ok: true, data: merged });
  } catch (error) {
    return c.json({ ok: false, error: 'Failed to update settings', message: String(error) }, 500);
  }
});

// PUT /admin/staff/:id/shift
app.put('/admin/staff/:id/shift', async (c) => {
  try {
    const staffId = c.req.param('id');
    const body = await c.req.json() as StaffShift;
    
    // validation
    if (!staffId || typeof staffId !== 'string' || staffId.trim() === '') {
      return c.json({ ok: false, error: 'staffId is required' }, 400);
    }
    if (!body.weekly || !Array.isArray(body.weekly)) {
      return c.json({ ok: false, error: 'weekly is required and must be array' }, 400);
    }
    if (!body.exceptions || !Array.isArray(body.exceptions)) {
      return c.json({ ok: false, error: 'exceptions is required and must be array' }, 400);
    }
    
    const kv = c.env.SAAS_FACTORY;
    const shiftData: StaffShift = {
      staffId,
      weekly: body.weekly,
      exceptions: body.exceptions,
    };
    
    // KVã«ä¿å­˜
    await kv.put(`shift:${staffId}`, JSON.stringify(shiftData));
    
    return c.json({ ok: true, data: shiftData });
  } catch (error) {
    return c.json({ ok: false, error: 'Failed to save shift', message: String(error) }, 500);
  }
});

// GET /admin/staff/:id/shift
app.get('/admin/staff/:id/shift', async (c) => {
  try {
    const staffId = c.req.param('id');
    
    if (!staffId || typeof staffId !== 'string' || staffId.trim() === '') {
      return c.json({ ok: false, error: 'staffId is required' }, 400);
    }
    
    const kv = c.env.SAAS_FACTORY;
    const shiftValue = await kv.get(`shift:${staffId}`);
    
    if (shiftValue) {
      const shift = JSON.parse(shiftValue) as StaffShift;
      return c.json({ ok: true, data: shift });
    }
    
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆç©ºã®ã‚·ãƒ•ãƒˆï¼‰
    return c.json({
      ok: true,
      data: {
        staffId,
        weekly: [],
        exceptions: [],
      } as StaffShift,
    });
  } catch (error) {
    return c.json({ ok: false, error: 'Failed to fetch shift', message: String(error) }, 500);
  }
});

// PATCH /admin/reservations/:id/assign
app.patch('/admin/reservations/:id', async (c) => {
  try {
    const reservationId = c.req.param('id');
    const body = await c.req.json();
    const { staffId } = body;
    
    // validation
    if (staffId !== undefined && staffId !== null && typeof staffId !== 'string') {
      return c.json({ ok: false, error: 'staffId must be string or null' }, 400);
    }
    
    const kv = c.env.SAAS_FACTORY;
    
    // äºˆç´„ã‚’æ¤œç´¢ï¼ˆå…¨æ™‚é–“å¸¯ã‚’ã‚¹ã‚­ãƒ£ãƒ³ï¼‰
    const timeSlots = ['10:00', '11:00', '12:00', '13:00', '14:00', '15:00', '16:00', '17:00', '18:00'];
    let foundReservation: any = null;
    let foundKey: string | null = null;
    
    // æ—¥ä»˜ã‚’æ¨æ¸¬ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒã€ç°¡æ˜“å®Ÿè£…ã¨ã—ã¦æœ€è¿‘7æ—¥é–“ã‚’ã‚¹ã‚­ãƒ£ãƒ³
    const today = new Date();
    for (let i = 0; i < 7; i++) {
      const date = new Date(today);
      date.setDate(date.getDate() - i);
      const dateStr = date.toISOString().split('T')[0];
      
      for (const time of timeSlots) {
        const key = `rsv:${dateStr}:${time}`;
        const value = await kv.get(key);
        if (value) {
          try {
            const reservation = JSON.parse(value);
            if (reservation.reservationId === reservationId || reservation.id === reservationId) {
              foundReservation = reservation;
              foundKey = key;
              break;
            }
          } catch (e) {
            // ãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
          }
        }
      }
      if (foundReservation) break;
    }
    
    if (!foundReservation) {
      return c.json({ ok: false, error: 'Reservation not found' }, 404);
    }
    
    // staffId ã‚’æ›´æ–°
    foundReservation.staffId = staffId || null;
    
    await kv.put(foundKey!, JSON.stringify(foundReservation));
    
    return c.json({ ok: true, data: foundReservation });
  } catch (error) {
    return c.json({ ok: false, error: 'Failed to assign staff', message: String(error) }, 500);
  }
});

// DELETE /admin/reservations/:id
app.delete('/admin/reservations/:id', async (c) => {
  try {
    const reservationId = c.req.param('id');
    
    // validation: reservationId å¿…é ˆ
    if (!reservationId || typeof reservationId !== 'string' || reservationId.trim() === '') {
      return c.json({ ok: false, error: 'reservationId is required' }, 400);
    }
    
    const kv = c.env.SAAS_FACTORY;
    
    // è¨­å®šã‚’å–å¾—ã—ã¦cancelMinutesã‚’ãƒã‚§ãƒƒã‚¯
    const settingsValue = await kv.get('settings:default');
    const settings: AdminSettings = settingsValue
      ? mergeSettings(DEFAULT_ADMIN_SETTINGS, JSON.parse(settingsValue))
      : DEFAULT_ADMIN_SETTINGS;
    
    // O(1) é€†å¼•ã: rsv:id:${reservationId} ã‹ã‚‰ date/time/status ã‚’å–å¾—
    const reverseKey = `rsv:id:${reservationId}`;
    const reverseValue = await kv.get(reverseKey);
    
    let foundReservation: any = null;
    let foundKey: string | null = null;
    let date: string | null = null;
    let time: string | null = null;
    let reverseStatus: string | null = null;
    
    if (reverseValue) {
      // é€†å¼•ããŒå­˜åœ¨ã™ã‚‹å ´åˆï¼ˆO(1)ï¼‰
      try {
        const reverseData = JSON.parse(reverseValue);
        date = reverseData.date;
        time = reverseData.time;
        reverseStatus = reverseData.status || 'active'; // å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯active
        
        // æ—¢ã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ¸ˆã¿ã®å ´åˆã¯å†ªç­‰ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™
        if (reverseStatus === 'canceled') {
          return c.json({ ok: false, error: 'already canceled' }, 409);
        }
        
        if (date && time) {
          foundKey = `rsv:${date}:${time}`;
          const reservationValue = await kv.get(foundKey);
          if (reservationValue) {
            foundReservation = JSON.parse(reservationValue);
            // äºˆç´„æœ¬ä½“ã®statusã‚‚ãƒã‚§ãƒƒã‚¯ï¼ˆå¿µã®ãŸã‚ï¼‰
            if (foundReservation.status === 'canceled') {
              return c.json({ ok: false, error: 'already canceled' }, 409);
            }
          }
        }
      } catch (e) {
        // ãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ã—ã¦fallbackã¸
        console.warn(`Failed to parse reverse index for ${reservationId}:`, e);
      }
    }
    
    // Fallback: é€†å¼•ããŒå­˜åœ¨ã—ãªã„å ´åˆï¼ˆå¤ã„äºˆç´„ï¼‰
    if (!foundReservation) {
      console.warn(`Reverse index not found for ${reservationId}, falling back to scan`);
      
      // æœ€è¿‘30æ—¥é–“ã‚’ã‚¹ã‚­ãƒ£ãƒ³
      const today = new Date();
      const timeSlots = ['10:00', '11:00', '12:00', '13:00', '14:00', '15:00', '16:00', '17:00', '18:00', '19:00'];
      
      for (let i = 0; i < 30; i++) {
        const scanDate = new Date(today);
        scanDate.setDate(scanDate.getDate() - i);
        const dateStr = scanDate.toISOString().split('T')[0];
        
        for (const t of timeSlots) {
          const key = `rsv:${dateStr}:${t}`;
          const value = await kv.get(key);
          if (value) {
            try {
              const reservation = JSON.parse(value);
              if (reservation.reservationId === reservationId || reservation.id === reservationId) {
                foundReservation = reservation;
                foundKey = key;
                date = reservation.date;
                time = reservation.time;
                
                // äºˆç´„æœ¬ä½“ã®statusã‚’ãƒã‚§ãƒƒã‚¯
                if (foundReservation.status === 'canceled') {
                  return c.json({ ok: false, error: 'already canceled' }, 409);
                }
                
                // Self-heal: é€†å¼•ãã‚’è£œå®Œä½œæˆï¼ˆstatus: "active"ï¼‰
                await kv.put(reverseKey, JSON.stringify({ date, time, status: 'active' }));
                // Self-healed reverse indexï¼ˆãƒ­ã‚°ã¯å‡ºåŠ›ã—ãªã„ï¼‰
                break;
              }
            } catch (e) {
              // ãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
            }
          }
        }
        if (foundReservation) break;
      }
    }
    
    if (!foundReservation || !date || !time) {
      return c.json({ ok: false, error: 'Reservation not found' }, 404);
    }
    
    // cancelMinutesã‚’ãƒã‚§ãƒƒã‚¯
    const reservationDateTime = new Date(`${date}T${time}:00+09:00`);
    const now = new Date();
    const jstOffset = 9 * 60; // åˆ†å˜ä½
    const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
    const nowJST = new Date(utc + (jstOffset * 60000));
    
    const diffMinutes = (reservationDateTime.getTime() - nowJST.getTime()) / (1000 * 60);
    if (diffMinutes < settings.rules.cancelMinutes) {
      return c.json({ ok: false, error: 'cancel cutoff passed' }, 409);
    }
    
    // Durable ObjectçµŒç”±ã§å‡¦ç†ï¼ˆãƒ­ãƒƒã‚¯ã‚­ãƒ¼: ${date}:${time}ï¼‰
    const lockKey = `${date}:${time}`;
    const id = c.env.SLOT_LOCK.idFromName(lockKey);
    const stub = c.env.SLOT_LOCK.get(id);
    
    // Durable Objectã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è»¢é€
    // Durable Objectã¯åŒä¸€IDã«å¯¾ã—ã¦åŒæ™‚ã«1ã¤ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã—ã‹å‡¦ç†ã—ãªã„ãŸã‚ã€
    // è‡ªç„¶ã«ãƒ­ãƒƒã‚¯ãŒã‹ã‹ã‚Šã€åŒæ™‚å‰Šé™¤ã‚’é˜²ã
    const doRequest = new Request('http://slot-lock/cancel', {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        date,
        time,
      }),
    });
    
    const response = await stub.fetch(doRequest);
    const result = await response.json();
    const status = response.status;
    
    // ã‚­ãƒ£ãƒ³ã‚»ãƒ«æˆåŠŸæ™‚ã«LINEé€šçŸ¥ã‚’é€ä¿¡ï¼ˆéåŒæœŸã€ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ï¼‰
    if (status === 200 && result.ok) {
      try {
        // é€šçŸ¥ãŒæœ‰åŠ¹ã§ã€LINEé€£æºæ¸ˆã¿ã®å ´åˆã®ã¿é€ä¿¡
        if (settings.integrations?.line?.connected && settings.integrations.line.notifyOnCancel !== false) {
          const message = `äºˆç´„ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ ğŸ¥²\näºˆç´„ID: ${reservationId}`;
          
          // éåŒæœŸã§é€šçŸ¥ã‚’é€ä¿¡ï¼ˆã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ï¼‰
          // D1ã‹ã‚‰è¨­å®šã‚’å–å¾—ï¼ˆãªã‘ã‚Œã°ç’°å¢ƒå¤‰æ•°ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
          getLineConfigOrNull({ DB: c.env.DB, CONFIG_ENC_KEY: c.env.CONFIG_ENC_KEY }, tenantId).then(async (config) => {
            let channelAccessToken: string | undefined;
            if (config) {
              channelAccessToken = config.channelAccessToken;
            } else {
              channelAccessToken = c.env.LINE_CHANNEL_ACCESS_TOKEN;
            }
            const userId = settings.integrations.line.userId;
            if (channelAccessToken && userId) {
              sendLineNotification(kv, channelAccessToken, userId, message)
              .then(async () => {
                // æˆåŠŸæ™‚: lastSentAt ã‚’è¨˜éŒ²
                const lastSentAtKey = `line:notify:lastSentAt:${tenantId}`;
                await kv.put(lastSentAtKey, JSON.stringify({
                  message,
                  at: Date.now(),
                }));
              })
              .catch(async (err) => {
                // ã‚¨ãƒ©ãƒ¼æ™‚: lastError ã‚’è¨˜éŒ²ï¼ˆç§˜å¯†å€¤ã¯ãƒ­ã‚°ã«å‡ºåŠ›ã—ãªã„ï¼‰
                const errorMessage = err instanceof Error ? err.message : String(err);
                // console.error ã¯ç§˜å¯†å€¤ã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ä½¿ç”¨ã—ãªã„
                const lastErrorKey = `line:notify:lastError:${tenantId}`;
                await kv.put(lastErrorKey, JSON.stringify({
                  message,
                  error: errorMessage,
                  at: Date.now(),
                }));
              });
            }
          }).catch(() => {
            // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
          });
        }
      } catch (err) {
        // é€šçŸ¥é€ä¿¡å¤±æ•—ã¯ç„¡è¦–ï¼ˆã‚­ãƒ£ãƒ³ã‚»ãƒ«ã¯æˆåŠŸã—ã¦ã„ã‚‹ãŸã‚ï¼‰
        // console.error ã¯ç§˜å¯†å€¤ã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ä½¿ç”¨ã—ãªã„
      }
    }
    
    return c.json(result, status);
  } catch (error) {
    return c.json({ ok: false, error: 'invalid request' }, 400);
  }
});

// POST /admin/settings/test-slack
app.post('/admin/settings/test-slack', async (c) => {
  try {
    const body = await c.req.json();
    const { webhookUrl } = body;
    
    const kv = c.env.SAAS_FACTORY;
    
    // webhookUrlãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯è¨­å®šã‹ã‚‰å–å¾—
    let targetWebhookUrl = webhookUrl;
    if (!targetWebhookUrl) {
      const settingsValue = await kv.get('settings:default');
      const settings: AdminSettings = settingsValue
        ? mergeSettings(DEFAULT_ADMIN_SETTINGS, JSON.parse(settingsValue))
        : DEFAULT_ADMIN_SETTINGS;
      targetWebhookUrl = settings.notifications.slackWebhookUrl;
    }
    
    if (!targetWebhookUrl || targetWebhookUrl.trim() === '') {
      return c.json({ ok: false, error: 'webhookUrl is required' }, 400);
    }
    
    // Slack Webhook URLã®å½¢å¼ãƒã‚§ãƒƒã‚¯
    if (!targetWebhookUrl.startsWith('https://hooks.slack.com/services/')) {
      return c.json({ ok: false, error: 'invalid webhook URL format' }, 400);
    }
    
    // Slackã«ãƒ†ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
    const slackResponse = await fetch(targetWebhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        text: 'Lumiere Admin ãƒ†ã‚¹ãƒˆé€šçŸ¥: è¨­å®šãŒæ­£å¸¸ã«å‹•ä½œã—ã¦ã„ã¾ã™ âœ…',
      }),
    });
    
    if (!slackResponse.ok) {
      const errorText = await slackResponse.text();
      return c.json({
        ok: false,
        error: `Slack API error: ${slackResponse.status} ${errorText}`,
      }, 500);
    }
    
    return c.json({ ok: true });
  } catch (error) {
    return c.json({
      ok: false,
      error: error instanceof Error ? error.message : 'Failed to send test notification',
    }, 500);
  }
});

// 404 ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
app.notFound((c) => {
  return c.json({
    ok: false,
    error: 'Not Found',
  }, 404);
});

// LINEè¨­å®šç®¡ç†ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆD1æš—å·åŒ–ä¿å­˜ï¼‰
// GET /admin/line/config
app.get('/admin/line/config', async (c) => {
  try {
    const tenantId = getTenantId(c);
    const db = c.env.DB;
    const masterKey = c.env.CONFIG_ENC_KEY;

    if (!masterKey) {
      return c.json({
        ok: false,
        error: 'CONFIG_ENC_KEY is not configured',
      }, 500);
    }

    const configured = await hasLineConfig(db, tenantId);
    let masked = null;

    if (configured) {
      const config = await getLineConfig(db, tenantId, masterKey);
      masked = getMaskedConfig(config);
    } else {
      masked = getMaskedConfig(null);
    }

    return c.json({
      ok: true,
      configured,
      masked,
    });
  } catch (err) {
    return c.json({
      ok: false,
      error: err instanceof Error ? err.message : 'Failed to get LINE config',
    }, 500);
  }
});

// GET /admin/line/client-id
app.get('/admin/line/client-id', async (c) => {
  try {
    const tenantId = getTenantId(c);
    
    // D1ã‹ã‚‰è¨­å®šã‚’å–å¾—ï¼ˆãªã‘ã‚Œã°ç’°å¢ƒå¤‰æ•°ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
    let clientId: string | undefined;
    const config = await getLineConfigOrNull({ DB: c.env.DB, CONFIG_ENC_KEY: c.env.CONFIG_ENC_KEY }, tenantId);
    if (config) {
      clientId = config.clientId;
    } else {
      // å¾Œæ–¹äº’æ›æ€§: ç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—
      clientId = c.env.LINE_CLIENT_ID;
    }

    if (!clientId) {
      return c.json({ ok: false, error: 'LINE_CLIENT_ID is not configured' }, 400);
    }

    return c.json({ ok: true, clientId });
  } catch (error) {
    return c.json({ ok: false, error: error instanceof Error ? error.message : 'Failed to get client ID' }, 500);
  }
});

// PUT /admin/line/config
app.put('/admin/line/config', async (c) => {
  try {
    const tenantId = getTenantId(c);
    const db = c.env.DB;
    const masterKey = c.env.CONFIG_ENC_KEY;

    if (!masterKey) {
      return c.json({
        ok: false,
        error: 'CONFIG_ENC_KEY is not configured',
      }, 500);
    }

    // TODO: RBACãƒã‚§ãƒƒã‚¯ï¼ˆOwner/Adminã®ã¿ï¼‰
    const actorUserId = 'admin'; // æš«å®š

    const body = await c.req.json<{
      clientId: string;
      channelAccessToken: string;
      channelSecret: string;
    }>();

    // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (!body.clientId || !body.channelAccessToken || !body.channelSecret) {
      return c.json({
        ok: false,
        error: 'clientId, channelAccessToken, and channelSecret are required',
      }, 400);
    }

    if (!/^\d+$/.test(body.clientId)) {
      return c.json({
        ok: false,
        error: 'clientId must be numeric',
      }, 400);
    }

    if (body.channelAccessToken.length < 10) {
      return c.json({
        ok: false,
        error: 'channelAccessToken is too short',
      }, 400);
    }

    if (body.channelSecret.length < 10) {
      return c.json({
        ok: false,
        error: 'channelSecret is too short',
      }, 400);
    }

    const config: LineConfigPlain = {
      clientId: body.clientId,
      channelAccessToken: body.channelAccessToken,
      channelSecret: body.channelSecret,
    };

    const wasConfigured = await hasLineConfig(db, tenantId);
    await saveLineConfig(db, tenantId, config, actorUserId, masterKey);
    await logAudit(
      db,
      tenantId,
      actorUserId,
      wasConfigured ? 'line_config_updated' : 'line_config_created',
      { clientIdLast4: body.clientId.slice(-4) }
    );

    const masked = getMaskedConfig(config);

    return c.json({
      ok: true,
      configured: true,
      masked,
    });
  } catch (err) {
    return c.json({
      ok: false,
      error: err instanceof Error ? err.message : 'Failed to save LINE config',
    }, 500);
  }
});

// DELETE /admin/line/config
app.delete('/admin/line/config', async (c) => {
  try {
    const tenantId = getTenantId(c);
    const db = c.env.DB;

    // TODO: RBACãƒã‚§ãƒƒã‚¯ï¼ˆOwner/Adminã®ã¿ï¼‰
    const actorUserId = 'admin'; // æš«å®š

    const wasConfigured = await hasLineConfig(db, tenantId);
    if (!wasConfigured) {
      return c.json({
        ok: false,
        error: 'LINE config not found',
      }, 404);
    }

    await deleteLineConfig(db, tenantId);
    await logAudit(db, tenantId, actorUserId, 'line_config_deleted');

    return c.json({
      ok: true,
      configured: false,
      masked: getMaskedConfig(null),
    });
  } catch (err) {
    return c.json({
      ok: false,
      error: err instanceof Error ? err.message : 'Failed to delete LINE config',
    }, 500);
  }
});

// LINEé€£æºã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
  // GET /admin/integrations/line/auth-url
  // LINEé€£æºã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ: LINEãƒ­ã‚°ã‚¤ãƒ³é–‹å§‹ç”¨ã®èªå¯URLã‚’è¿”ã™
  app.get('/admin/integrations/line/auth-url', async (c) => {
    try {
      const tenantId = getTenantId(c);

      // D1ã‹ã‚‰è¨­å®šã‚’å–å¾—ï¼ˆãªã‘ã‚Œã°ç’°å¢ƒå¤‰æ•°ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
      let clientId: string | undefined;
      const config = await getLineConfigOrNull(
        { DB: c.env.DB, CONFIG_ENC_KEY: c.env.CONFIG_ENC_KEY },
        tenantId,
      );

      if (config) {
        clientId = config.clientId;
      } else {
        // å¾Œæ–¹äº’æ›æ€§: ç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—
        clientId = c.env.LINE_CLIENT_ID;
      }

      if (!clientId) {
        return c.json(
          { ok: false, error: 'LINE_CLIENT_ID is not configured' },
          500,
        );
      }

      // Redirect Base URL ã‚’å–å¾—ï¼ˆç’°å¢ƒå¤‰æ•°ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ç”¨ã€ãªã‘ã‚Œã°ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã‚‰ç”Ÿæˆï¼‰
      let redirectBase: string;
      if (c.env.LINE_LOGIN_REDIRECT_BASE) {
        redirectBase = c.env.LINE_LOGIN_REDIRECT_BASE.replace(/\/$/, '');
      } else {
        const url = new URL(c.req.url);
        redirectBase = `${url.protocol}//${url.host}`;
      }

      // callback å…ˆã¯ Next /admin/integrations/line/callback ã«æƒãˆã‚‹
      const redirectUri = `${redirectBase}/admin/integrations/line/callback`;

      // state = tenantId:nonce ã‚’ç”Ÿæˆã—ã¦ KV ã«ä¿å­˜ï¼ˆCSRF å¯¾ç­–ï¼‰
      const nonce = crypto.randomUUID();
      const state = `${tenantId}:${nonce}`;

      const kv = c.env.SAAS_FACTORY;
      await kv.put(
        `line:state:${nonce}`,
        JSON.stringify({ tenantId, createdAt: Date.now() }),
        { expirationTtl: 600 },   // 10åˆ†
      );

      // LINE èªå¯URLã‚’ç”Ÿæˆ
      const authUrl = buildLineAuthUrl(clientId, redirectUri, state);

      return c.json({ ok: true, url: authUrl });
      
  // GET /admin/integrations/line/status
  app.get('/admin/integrations/line/status', (c) => {
    const tenantId = c.req.query('tenantId') ?? 'default'
    return c.json({ ok: true, tenantId, kind: 'unconfigured' })
  });

  // GET /admin/integrations/line/status
  app.get('/admin/integrations/line/status', (c) => {
    const tenantId = getTenantId(c);
    return c.json({ ok: true, tenantId, kind: 'unconfigured' })
  });
} catch (error) {
      return c.json(jsonError(error), 500);
    }
  });
export default app;
import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { DEFAULT_ADMIN_SETTINGS, validateAdminSettings, mergeSettings, type AdminSettings } from './settings';
import { getBusinessHoursForDate, generateSlots, getTodayJST, isWorkingTime, timeToMinutes, getNowMinutesJST } from './slotUtils';
import { buildLineAuthUrl, exchangeCodeForToken, verifyAccessToken, sendLineMessage, sendLineNotification, verifyLineWebhookSignature } from './integrations/line';
import { getLineConfig, saveLineConfig, deleteLineConfig, hasLineConfig, logAudit, getMaskedConfig, type LineConfigPlain } from './lineConfig';
import { getLineConfigOrNull, getLineConfigRequired, jsonError } from './line/config';
import { getLineConfigOrNull, getLineConfigRequired, jsonError } from './line/config';

type Env = {
  ENVIRONMENT?: string;
  VERSION?: string;
  SAAS_FACTORY: KVNamespace;
  SLOT_LOCK: DurableObjectNamespace<SlotLock>;
  DB: D1Database;
  CONFIG_ENC_KEY?: string; // æš—å·åŒ–ãƒã‚¹ã‚¿ãƒ¼ã‚­ãƒ¼ï¼ˆbase64 32byteï¼‰
  LINE_CLIENT_ID?: string; // LINE Login Client ID
  LINE_LOGIN_CHANNEL_ID?: string; // LINE Login Channel ID
  LINE_LOGIN_CHANNEL_SECRET?: string; // LINE Login Channel Secret
  LINE_LOGIN_REDIRECT_BASE?: string; // LINE Login Redirect Base URL (ä¾‹: http://localhost:3000)
  LINE_REDIRECT_URI?: string; // LINE OAuth Redirect URI (ä¾‹: http://localhost:3000/admin/integrations/line/callback)
  LINE_CHANNEL_ACCESS_TOKEN?: string; // å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼ˆD1ç§»è¡Œå¾Œã¯å‰Šé™¤äºˆå®šï¼‰
  LINE_CHANNEL_SECRET?: string; // å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼ˆD1ç§»è¡Œå¾Œã¯å‰Šé™¤äºˆå®šï¼‰
  WEB_BASE_URL?: string; // ä¾‹: http://localhost:3000
};





