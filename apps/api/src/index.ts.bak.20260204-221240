import { Hono } from "hono"
import { Hono } from "hono"
import {
  getIntegration,
  upsertIntegration,
  setNotifyEnabled,
  disconnectIntegration,
  insertSendLog,
} from "./integrations/line/store"

// SAAS-FACTORY API ENTRY (apps/api/src/index.ts)
import { getMessagingStatus, saveMessagingConfig, deleteMessagingConfig } from "./integrations/line/messaging"
type Env = {
  DB: D1Database
  LINE_CLIENT_ID?: string
  LINE_LOGIN_CHANNEL_ID?: string
  LINE_LOGIN_CHANNEL_SECRET?: string
  LINE_LOGIN_REDIRECT_BASE?: string
  LINE_CHANNEL_ACCESS_TOKEN?: string
  LINE_MESSAGING_CHANNEL_ACCESS_TOKEN?: string
}

const app = new Hono<{ Bindings: Env }>()

/* ===== TEMP DEBUG onError (auto-injected) ===== */
app.onError((err, c) => {
  // TEMP DEBUG: expose error details so we can fix /slots 500 quickly.
  // TODO: revert to safe generic error after fix.
  const e: any = err as any;





/* ===== TEMP HOTFIX getBusinessHoursForDate (globalThis) ===== */
;(function initGetBusinessHoursForDate(){
  const g:any = globalThis as any;
  if(!g.getBusinessHoursForDate){
    g.getBusinessHoursForDate = function(...args: any[]){
      const settings =
        args.find(a => a && typeof a === "object" && (a.businessHours || a.closedWeekdays || a.timezone)) ??
        g.DEFAULT_ADMIN_SETTINGS ??
        { businessHours: { start: "09:00", end: "20:00" }, closedWeekdays: [] };

      const dateArg = args.find(a => typeof a === "string" || a instanceof Date) ?? null;

      try {
        if(dateArg && settings.closedWeekdays && Array.isArray(settings.closedWeekdays) && settings.closedWeekdays.length){
          const d = (dateArg instanceof Date) ? dateArg : new Date(String(dateArg) + "T00:00:00+09:00");
          const wd = d.getDay(); // 0=Sun..6=Sat
          if(settings.closedWeekdays.includes(wd)){
            return { start: "00:00", end: "00:00", closed: true };
          }
        }
      } catch {}

      return settings.businessHours ?? { start: "09:00", end: "20:00" };
    };
  }
})();
/* ===== END TEMP HOTFIX getBusinessHoursForDate ===== */

/* ===== TEMP RESTORE (globalThis as any).getBusinessHoursForDate ===== */
function (globalThis as any).getBusinessHoursForDate(...args: any[]) {
  const g:any = globalThis as any;
  const settings =
    args.find(a => a && typeof a === "object" && (a.businessHours || a.closedWeekdays || a.timezone)) ??
    g.DEFAULT_ADMIN_SETTINGS ??
    { businessHours: { start: "09:00", end: "20:00" }, closedWeekdays: [] };

  const dateArg = args.find(a => typeof a === "string" || a instanceof Date) ?? null;

  try {
    if(dateArg && settings.closedWeekdays && Array.isArray(settings.closedWeekdays) && settings.closedWeekdays.length){
      const d = (dateArg instanceof Date) ? dateArg : new Date(String(dateArg) + "T00:00:00+09:00");
      const wd = d.getDay(); // 0=Sun..6=Sat
      if(settings.closedWeekdays.includes(wd)){
        return { start: "00:00", end: "00:00", closed: true };
      }
    }
  } catch {}

  return settings.businessHours ?? { start: "09:00", end: "20:00" };
}
/* ===== END TEMP RESTORE (globalThis as any).getBusinessHoursForDate ===== */

/* ===== TEMP HOTFIX DEFAULT_ADMIN_SETTINGS (globalThis) ===== */
;(function initDefaultAdminSettings(){
  const g:any = globalThis as any;
  if(!g.DEFAULT_ADMIN_SETTINGS){
    g.DEFAULT_ADMIN_SETTINGS = {
      timezone: "Asia/Tokyo",
      slotMinutes: 30,
      cutoffMinutes: 0,
      businessHours: { start: "09:00", end: "20:00" },
      closedWeekdays: [],
    };
  }
})();
/* ===== END TEMP HOTFIX DEFAULT_ADMIN_SETTINGS ===== */

  const msg = String(e?.message ?? e ?? "unknown_error");
  
const stack = String(e?.stack ?? "");
  const path = c.req.path;

  console.error("[onError]", { path, msg, stack });

  // Return JSON for easier diagnosis (esp /slots)
  return c.json({ ok: false, error: "internal_error", path, message: msg, stack }, 500);
});
/* ===== END TEMP DEBUG onError ===== */

/* ===== restored booking core routes (from index.ts.bak-20260120-authurl-fix) ===== */
// GET /slots?date=YYYY-MM-DD&staffId=xxx(optional)
app.get('/slots', async (c) => {
  const dateStr = c.req.query('date');
  const staffId = c.req.query('staffId'); // optional
  const debug = c.req.query('debug');
  
  // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰: debug=1 ã§ä¾å­˜ã‚¼ãƒ­ã§å³ return
  if (debug === '1') {
    return c.json({ ok: true, stage: 'entered', date: dateStr, staffId: staffId || null });
  }
  
  // date ãŒãªã„/ä¸æ­£ãªã‚‰ 400
  if (!dateStr) {
    return c.json({ ok: false, error: 'invalid date' }, 400);
  }
  
  // æ—¥ä»˜å½¢å¼ã®æ¤œè¨¼ (YYYY-MM-DD)
  const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
  if (!dateRegex.test(dateStr)) {
    return c.json({ ok: false, error: 'invalid date' }, 400);
  }
  
  // æ—¥ä»˜ãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
  const date = new Date(dateStr + 'T00:00:00+09:00'); // JSTã¨ã—ã¦è§£é‡ˆ
  if (isNaN(date.getTime())) {
    return c.json({ ok: false, error: 'invalid date' }, 400);
  }
  
  const kv = c.env.SAAS_FACTORY;
  
  // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰: debug=2 ã§ settings ã‚’å–å¾—
  if (debug === '2') {
    try {
      const settingsValue = await kv.get('settings:default');
      const hasSettings = !!settingsValue;
      return c.json({ 
        ok: true, 
        stage: 'settings_fetched', 
        date: dateStr,
        hasSettings,
        settingsLength: settingsValue?.length || 0
      });
    } catch (e) {
      return c.json({ 
        ok: false, 
        stage: 'settings_error', 
        error: e instanceof Error ? e.message : String(e) 
      }, 500);
    }
  }
  
  // è¨­å®šã‚’å–å¾—
  const settingsValue = await kv.get('settings:default');
  const settings: AdminSettings = settingsValue
    ? mergeSettings((globalThis as any).DEFAULT_ADMIN_SETTINGS, JSON.parse(settingsValue))
    : (globalThis as any).DEFAULT_ADMIN_SETTINGS;
  
  // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰: debug=3 ã§ shift ã‚’èª­ã‚€
  if (debug === '3') {
    try {
      let shiftPresent = false;
      let staffListPresent = false;
      
      if (staffId) {
        const shiftValue = await kv.get(`shift:${staffId}`);
        shiftPresent = !!shiftValue;
      }
      
      // staff list ã‚‚ç¢ºèª
      const staffListValue = await kv.get('staff:list');
      staffListPresent = !!staffListValue;
      
      return c.json({ 
        ok: true, 
        stage: 'shift_fetched', 
        date: dateStr,
        staffId: staffId || null,
        shiftPresent,
        staffListPresent
      });
    } catch (e) {
      return c.json({ 
        ok: false, 
        stage: 'error', 
        error: e instanceof Error ? e.message : String(e) 
      }, 500);
    }
  }
  
  // å–¶æ¥­æ™‚é–“ã‚’å–å¾—ï¼ˆå®šä¼‘æ—¥ãƒ»ä¾‹å¤–æ—¥ã‚’è€ƒæ…®ï¼‰
  const businessHours = (globalThis as any).getBusinessHoursForDate(dateStr, settings);
  
  if (!businessHours) {
    // ä¼‘æ¥­æ—¥ã¾ãŸã¯å®šä¼‘æ—¥
    return c.json({
      ok: true,
      date: dateStr,
      slots: [],
    });
  }
  
  // ã‚¹ãƒ­ãƒƒãƒˆé–“éš”ã‚’å–å¾—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ30åˆ†ï¼‰
  const slotIntervalMin = settings.businessHours.slotIntervalMin || 30;
  
  // staffId ãŒã‚ã‚‹å ´åˆã€ãã®ã‚¹ã‚¿ãƒƒãƒ•ã®ã‚·ãƒ•ãƒˆã‚’å–å¾—
  let staffShift: StaffShift | null = null;
  if (staffId) {
    try {
      const shiftValue = await kv.get(`shift:${staffId}`);
      if (shiftValue) {
        staffShift = JSON.parse(shiftValue) as StaffShift;
      }
    } catch (e) {
      console.warn(`Failed to load shift for staff ${staffId}:`, e);
    }
  }
  
  // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰: debug=4 ã§äºˆç´„æ¸ˆã¿ã‚­ãƒ¼ã®å‚ç…§ã¾ã§
  if (debug === '4') {
    try {
      // æœ€åˆã®ã‚¹ãƒ­ãƒƒãƒˆã®äºˆç´„ã‚­ãƒ¼ã‚’å‚ç…§ï¼ˆã‚¹ãƒ­ãƒƒãƒˆç”Ÿæˆã¯ã—ãªã„ï¼‰
      // ä»®ã®æ™‚é–“ã§ã‚­ãƒ¼ã‚’æ§‹ç¯‰ã—ã¦å‚ç…§ã™ã‚‹ã ã‘
      const testKey = `rsv:${dateStr}:10:00`;
      const existing = await kv.get(testKey);
      const reservedPresent = !!existing;
      return c.json({ 
        ok: true, 
        stage: 'reserved_key_checked', 
        date: dateStr,
        testKey,
        reservedPresent
      });
    } catch (e) {
      return c.json({ 
        ok: false, 
        stage: 'error', 
        error: e instanceof Error ? e.message : String(e) 
      }, 500);
    }
  }
  
  // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰: debug=5 ã§ã‚¹ãƒ­ãƒƒãƒˆç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ç›´å‰ã¾ã§
  if (debug === '5') {
    return c.json({ 
      ok: true, 
      stage: 'before_slot_generation', 
      date: dateStr,
      hasBusinessHours: !!businessHours,
      slotIntervalMin,
      hasShift: !!staffShift,
      staffId: staffId || null
    });
  }
  
  // ã‚¹ãƒ­ãƒƒãƒˆã‚’ç”Ÿæˆ
  const timeSlots = generateSlots(businessHours.openTime, businessHours.closeTime, slotIntervalMin);
  
  // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰: debug=6 ã§ã‚¹ãƒ­ãƒƒãƒˆç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè¡Œã—ã¦ stage=done ã§è¿”ã™
  if (debug === '6') {
    try {
      // ç„¡é™ãƒ«ãƒ¼ãƒ—æ¤œçŸ¥: maxIterations ã‚¬ãƒ¼ãƒ‰
      const maxIterations = 5000;
      let iterationCount = 0;
      
      // ã‚¹ãƒ­ãƒƒãƒˆç”Ÿæˆå¾Œã®å‡¦ç†ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆï¼ˆæœ€åˆã®æ•°å€‹ã ã‘ï¼‰
      const sampleSlots = timeSlots.slice(0, Math.min(5, timeSlots.length));
      const sampleResults = await Promise.all(
        sampleSlots.map(async (time) => {
          iterationCount++;
          if (iterationCount > maxIterations) {
            throw new Error(`Max iterations (${maxIterations}) exceeded`);
          }
          
          const key = `rsv:${dateStr}:${time}`;
          const existing = await kv.get(key);
          return {
            time,
            key,
            reserved: !!existing
          };
        })
      );
      
      return c.json({ 
        ok: true, 
        stage: 'done', 
        date: dateStr,
        totalSlots: timeSlots.length,
        sampleSlots: sampleResults.length,
        iterationCount,
        firstSlot: timeSlots[0] || null,
        lastSlot: timeSlots[timeSlots.length - 1] || null
      });
    } catch (e) {
      return c.json({ 
        ok: false, 
        stage: 'error', 
        error: e instanceof Error ? e.message : String(e) 
      }, 500);
    }
  }
  
  // KVã‹ã‚‰äºˆç´„æ¸ˆã¿ã‚¹ãƒ­ãƒƒãƒˆã‚’ç¢ºèªã—ã€cutoffMinutesã¨shiftã‚’é©ç”¨
  // reason ã®å„ªå…ˆé †ä½: 1) reserved, 2) cutoff, 3) closed, 4) shift
  // ç„¡é™ãƒ«ãƒ¼ãƒ—æ¤œçŸ¥: maxIterations ã‚¬ãƒ¼ãƒ‰
  const maxIterations = 5000;
  let iterationCount = 0;
  
  const slots = await Promise.all(
    timeSlots.map(async (time) => {
      iterationCount++;
      if (iterationCount > maxIterations) {
        throw new Error(`Max iterations (${maxIterations}) exceeded in slot processing`);
      }
      // ç†ç”±ã‚’å„ªå…ˆé †ä½ã§åˆ¤å®š
      const reasons: string[] = [];
      
      // 1. closed ãƒã‚§ãƒƒã‚¯ï¼ˆå–¶æ¥­æ™‚é–“å¤–ï¼‰
      if (!businessHours) {
        reasons.push('closed');
      }
      
      // 2. reserved ãƒã‚§ãƒƒã‚¯ï¼ˆäºˆç´„æ¸ˆã¿ã€ã‹ã¤statusãŒactiveï¼‰
      const key = `rsv:${dateStr}:${time}`;
      const existing = await kv.get(key);
      if (existing) {
        try {
          const reservation = JSON.parse(existing);
          // statusãŒ"canceled"ã§ãªã„å ´åˆã®ã¿äºˆç´„æ¸ˆã¿ã¨ã¿ãªã™
          if (reservation.status !== 'canceled') {
            reasons.push('reserved');
          }
        } catch (e) {
          // ãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
        }
      }
      
      // 3. cutoff ãƒã‚§ãƒƒã‚¯ï¼ˆå½“æ—¥ã‹ã¤cutoffMinutesä»¥å†…ï¼‰
      const today = getTodayJST();
      if (dateStr === today) {
        const nowMin = getNowMinutesJST();
        const slotMin = timeToMinutes(time);
        const diffMinutes = slotMin - nowMin;
        if (diffMinutes < settings.rules.cutoffMinutes) {
          reasons.push('cutoff');
        }
      }
      
      // 4. shift ãƒã‚§ãƒƒã‚¯ï¼ˆstaffIdãŒã‚ã‚‹å ´åˆã€å‹¤å‹™æ™‚é–“å¤–ï¼‰
      if (staffId && staffShift) {
        const isWorking = isWorkingTime(dateStr, time, staffShift);
        if (!isWorking) {
          reasons.push('shift');
        }
      }
      
      // å„ªå…ˆé †ä½ã§æœ€åˆã®reasonã‚’æ¡ç”¨: reserved > cutoff > closed > shift
      const reasonPriority: Record<string, number> = {
        reserved: 1,
        cutoff: 2,
        closed: 3,
        shift: 4,
      };
      
      let finalReason: string | undefined = undefined;
      if (reasons.length > 0) {
        reasons.sort((a, b) => (reasonPriority[a] || 999) - (reasonPriority[b] || 999));
        finalReason = reasons[0];
      }
      
      // availableåˆ¤å®š: ã„ãšã‚Œã‹ã®ç†ç”±ãŒã‚ã‚Œã°false
      const available = finalReason === undefined;
      
      return {
        time,
        available,
        ...(finalReason ? { reason: finalReason as 'cutoff' | 'reserved' | 'shift' | 'closed' } : {}),
      };
    })
  );
  
  return c.json({
    ok: true,
    date: dateStr,
    ...(staffId ? { staffId } : {}),
    slots,
  });
});

// POST /reserve
app.post('/reserve', async (c) => {
  try {
    const body = await c.req.json();
    const { date, time, name, phone } = body;
    
    // validation: date/time/name å¿…é ˆã€‚phoneã¯ä»»æ„
    if (!date || typeof date !== 'string') {
      return c.json({ ok: false, error: 'date is required' }, 400);
    }
    if (!time || typeof time !== 'string') {
      return c.json({ ok: false, error: 'time is required' }, 400);
    }
    if (!name || typeof name !== 'string' || name.trim() === '') {
      return c.json({ ok: false, error: 'name is required' }, 400);
    }
    
    // Durable ObjectçµŒç”±ã§å‡¦ç†ï¼ˆãƒ­ãƒƒã‚¯ã‚­ãƒ¼: ${date}:${time}ï¼‰
    const lockKey = `${date}:${time}`;
    const id = c.env.SLOT_LOCK.idFromName(lockKey);
    const stub = c.env.SLOT_LOCK.get(id);
    
    // Durable Objectã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è»¢é€
    // Durable Objectã¯åŒä¸€IDã«å¯¾ã—ã¦åŒæ™‚ã«1ã¤ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã—ã‹å‡¦ç†ã—ãªã„ãŸã‚ã€
    // è‡ªç„¶ã«ãƒ­ãƒƒã‚¯ãŒã‹ã‹ã‚Šã€äºŒé‡äºˆç´„ã‚’é˜²ã
    const doRequest = new Request('http://slot-lock/reserve', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
    });
    
    const response = await stub.fetch(doRequest);
    const result = await response.json();
    const status = response.status;
    
    // äºˆç´„ä½œæˆæˆåŠŸæ™‚ã«LINEé€šçŸ¥ã‚’é€ä¿¡ï¼ˆéåŒæœŸã€ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ï¼‰
    if (status === 200 && result.ok) {
      try {
        const kv = c.env.SAAS_FACTORY;
        const tenantId = getTenantId(c);
        
        // settings ã‚’å–å¾—ã—ã¦é€šçŸ¥ãƒ«ãƒ¼ãƒ«ã‚’ç¢ºèª
        const settingsValue = await kv.get('settings:default');
        const settings: AdminSettings = settingsValue
          ? mergeSettings((globalThis as any).DEFAULT_ADMIN_SETTINGS, JSON.parse(settingsValue))
          : (globalThis as any).DEFAULT_ADMIN_SETTINGS;
        
        // é€šçŸ¥ãŒæœ‰åŠ¹ã§ã€LINEé€£æºæ¸ˆã¿ã®å ´åˆã®ã¿é€ä¿¡
        if (settings.integrations?.line?.connected && settings.integrations.line.notifyOnReservation !== false) {
          const { date, time, name, reservationId, staffId } = result;
          
          // ã‚¹ã‚¿ãƒƒãƒ•åã‚’å–å¾—ï¼ˆã‚ã‚Œã°ï¼‰
          let staffName = 'æŒ‡åãªã—';
          if (staffId) {
            try {
              const staffValue = await kv.get(`staff:${staffId}`);
              if (staffValue) {
                const staff = JSON.parse(staffValue);
                staffName = staff.name || staffId;
              }
            } catch (e) {
              // ã‚¹ã‚¿ãƒƒãƒ•å–å¾—å¤±æ•—ã¯ç„¡è¦–
            }
          }
          
          // ãƒ¡ãƒ‹ãƒ¥ãƒ¼æƒ…å ±ã‚’å–å¾—ï¼ˆã‚ã‚Œã°ã€bodyã«menuIdãŒã‚ã‚Œã°ï¼‰
          let menuName = 'ãƒ¡ãƒ‹ãƒ¥ãƒ¼æœªæŒ‡å®š';
          if (body.menuId) {
            try {
              const menuValue = await kv.get(`menu:${body.menuId}`);
              if (menuValue) {
                const menu = JSON.parse(menuValue);
                menuName = menu.name || body.menuId;
              }
            } catch (e) {
              // ãƒ¡ãƒ‹ãƒ¥ãƒ¼å–å¾—å¤±æ•—ã¯ç„¡è¦–
            }
          }
          
          const message = `äºˆç´„ãŒç¢ºå®šã—ã¾ã—ãŸ âœ…\næ—¥æ™‚: ${date} ${time}\nãƒ¡ãƒ‹ãƒ¥ãƒ¼: ${menuName}\nã‚¹ã‚¿ãƒƒãƒ•: ${staffName}\näºˆç´„ID: ${reservationId}`;
          
          // éåŒæœŸã§é€šçŸ¥ã‚’é€ä¿¡ï¼ˆã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ï¼‰
          // D1ã‹ã‚‰è¨­å®šã‚’å–å¾—ï¼ˆãªã‘ã‚Œã°ç’°å¢ƒå¤‰æ•°ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
          getLineConfigOrNull({ DB: c.env.DB, CONFIG_ENC_KEY: c.env.CONFIG_ENC_KEY }, tenantId).then(async (config) => {
            let channelAccessToken: string | undefined;
            if (config) {
              channelAccessToken = config.channelAccessToken;
            } else {
              channelAccessToken = c.env.LINE_CHANNEL_ACCESS_TOKEN;
            }
            const userId = settings.integrations.line.userId;
            if (channelAccessToken && userId) {
              sendLineNotification(kv, channelAccessToken, userId, message)
              .then(async () => {
                // æˆåŠŸæ™‚: lastSentAt ã‚’è¨˜éŒ²
                const lastSentAtKey = `line:notify:lastSentAt:${tenantId}`;
                await kv.put(lastSentAtKey, JSON.stringify({
                  message,
                  at: Date.now(),
                }));
              })
              .catch(async (err) => {
                // ã‚¨ãƒ©ãƒ¼æ™‚: lastError ã‚’è¨˜éŒ²ï¼ˆç§˜å¯†å€¤ã¯ãƒ­ã‚°ã«å‡ºåŠ›ã—ãªã„ï¼‰
                const errorMessage = err instanceof Error ? err.message : String(err);
                // console.error ã¯ç§˜å¯†å€¤ã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ä½¿ç”¨ã—ãªã„
                const lastErrorKey = `line:notify:lastError:${tenantId}`;
                await kv.put(lastErrorKey, JSON.stringify({
                  message,
                  error: errorMessage,
                  at: Date.now(),
                }));
              });
            }
          }).catch(() => {
            // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
          });
        }
      } catch (err) {
        // é€šçŸ¥é€ä¿¡å¤±æ•—ã¯ç„¡è¦–ï¼ˆäºˆç´„ä½œæˆã¯æˆåŠŸã—ã¦ã„ã‚‹ãŸã‚ï¼‰
        // console.error ã¯ç§˜å¯†å€¤ã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ä½¿ç”¨ã—ãªã„
      }
    }
    
    return c.json(result, status);
  } catch (error) {
    return c.json({ ok: false, error: 'Invalid request body' }, 400);
  }
});
/* ===== end restored booking core routes ===== */


// tenantId ãŒãªã‘ã‚Œã° default
const getTenantId = (req: Request): string => {
  const url = new URL(req.url)
  return url.searchParams.get("tenantId") ?? "default"
}

function resolveLineClientId(env: Env): string {
  return env.LINE_CLIENT_ID || env.LINE_LOGIN_CHANNEL_ID || ""
}

function resolveLineChannelAccessToken(env: Env): string {
  return env.LINE_CHANNEL_ACCESS_TOKEN || env.LINE_MESSAGING_CHANNEL_ACCESS_TOKEN || ""
}

async function pushLineMessage(env: Env, to: string, text: string): Promise<Response> {
  const token = resolveLineChannelAccessToken(env)
  if (!token) {
    return new Response(JSON.stringify({ ok: false, error: "LINE channel access token missing" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    })
  }

  return fetch("https://api.line.me/v2/bot/message/push", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": "Bearer " + token,
    },
    body: JSON.stringify({
      to,
      messages: [{ type: "text", text }],
    }),
  })
}

// ãƒ«ãƒ¼ãƒˆ: GET /
app.get("/", (c) => c.text("Hello from SaaS Factory API!"))

// ãƒ«ãƒ¼ãƒˆ: GET /health
app.get("/health", (c) => {
  return c.json({
    ok: true,
    ts: new Date().toISOString(),
    env: (c.env.ENVIRONMENT ?? "unknown"),
    version: "1.0.0",
  })
})

app.get("/__debug_guard", (c) => {
  return c.json({ ok: true, guard: "vD1-GUARD-20260125" })
})

// ãƒ«ãƒ¼ãƒˆ: GET /admin/integrations/line/auth-url?tenantId=xxx
// LINE OAuth èªè¨¼URLã‚’ç”Ÿæˆã™ã‚‹ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
app.get("/admin/integrations/line/auth-url", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? "default"
    const env = c.env

    // client_id è§£æ±ºï¼ˆæ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç¶­æŒï¼‰
    const clientId = resolveLineClientId(env)

    // redirect_uri ã‚’æ§‹ç¯‰ï¼ˆNext.js å´ã® callback ã«å‘ã‘ã‚‹ï¼‰
    // â˜… ã“ã“ãŒãƒã‚¤ãƒ³ãƒˆï¼š
    //     .dev.vars ã® LINE_LOGIN_REDIRECT_BASE ã‚’ãã®ã¾ã¾ä½¿ã†
    //     ä¾‹: http://localhost:3000  ã¾ãŸã¯ http://localhost:8787
    const redirectBase = env.LINE_LOGIN_REDIRECT_BASE ?? "http://localhost:3000"
    const redirectUri = `${redirectBase.replace(/\/$/, "")}/api/auth/line/callback`

    if (!clientId) {
      return c.json(
        { ok: false, error: "LINE_CLIENT_ID is not configured" },
        400,
      )
    }

    const params = new URLSearchParams({
      response_type: "code",
      client_id: clientId,
      redirect_uri: redirectUri,
      scope: "profile openid",
      state: tenantId,
    })

    const url = `https://access.line.me/oauth2/v2.1/authorize?${params.toString()}`

    return c.json({ ok: true, url })
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error"
    console.error("[LINE OAuth] auth-url error:", errorMessage)

    return c.json(
      {
        ok: false,
        error: "internal_server_error",
        message: `LINE OAuthèªè¨¼URLã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${errorMessage}`,
      },
      500,
    )
  }
})

// ãƒ«ãƒ¼ãƒˆ: GET /admin/integrations/line/status
app.get("/admin/integrations/line/status", async (c) => {
  try {
    const tenantId = getTenantId(c.req.raw)
    const db = c.env.DB

    const integration = await getIntegration(db, tenantId)

    if (!integration) {
      return c.json({
        ok: true,
        tenantId,
        kind: "unconfigured" as const,
      })
    }

    return c.json({
      ok: true,
      tenantId,
      kind: "linked" as const,
      line: {
        userId: integration.user_id,
        displayName: integration.display_name,
        pictureUrl: integration.picture_url || undefined,
        updatedAt: integration.updated_at,
      },
      notifyEnabled: integration.notify_enabled === 1,
      linkedAt: integration.linked_at,
    })
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error"
    console.error("[LINE][status] error:", errorMessage)
    return c.json({
      ok: false,
      tenantId: getTenantId(c.req.raw),
      kind: "error" as const,
      message: "Failed to fetch LINE integration status",
      error: errorMessage,
    }, 500)
  }
})

// GET /api/auth/line/callback
// LINE Login ã¯ GET ã§ code/state ã‚’è¿”ã™ã®ã§ã€æ—¢å­˜ã® POST ãƒãƒ³ãƒ‰ãƒ©ã¸æ©‹æ¸¡ã—ã™ã‚‹
app.get("/api/auth/line/callback__old", async (c) => {
  const url = new URL(c.req.url)
  console.log("[LINE OAuth][callback:get] url=", url.toString())
  console.log("[LINE OAuth][callback:get] qs=", url.searchParams.toString())
  const code = url.searchParams.get("code")
  const state = url.searchParams.get("state") ?? "default"

  if (!code) return c.json({ ok: false, error: "missing code" }, 400)

  // åŒä¸€ Worker å†…ã® POST /api/auth/line/callback ã«è»¢é€
  const forwardUrl = new URL(c.req.url)
  forwardUrl.pathname = "/api/auth/line/callback"
  forwardUrl.search = ""

  const res = await fetch(forwardUrl.toString(), {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ code, state }),
  })

  const txt = await res.text().catch(() => "")
  if (!res.ok) {
    return c.json(
      { ok: false, error: "callback forward failed", status: res.status, detail: txt },
      400
    )
  }

  // POST ãŒ JSON ã‚’è¿”ã™å‰æã€‚è¿”ã•ãªã„ãªã‚‰ txt ã‚’è¿”ã™ã€‚
  try {
    return c.json(JSON.parse(txt))
  } catch {
    return c.text(txt)
  }
})

app.get("/api/auth/line/callback__old", async (c) => {
  const url = new URL(c.req.url)
  console.log("[LINE OAuth][callback:get] url=", url.toString())
  console.log("[LINE OAuth][callback:get] qs=", url.searchParams.toString())
  const code = url.searchParams.get("code") ?? ""
  const state = url.searchParams.get("state") ?? ""
  const tenantId = url.searchParams.get("tenantId") ?? state ?? getTenantId(c.req.raw)

  if (!code) {
    return c.redirect("http://localhost:3000/admin/settings?line=error_no_code", 307)
  }

  const res = await fetch(`${new URL(c.req.url).origin}/api/auth/line/callback`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ code, state, tenantId }),
  })

  const txt = await res.text()
  console.log("[LINE OAuth][callback:get->post] status=", res.status, "body=", txt)

  if (res.ok) {
    return c.redirect("http://localhost:3000/admin/settings?line=ok", 307)
  }
  return c.redirect("http://localhost:3000/admin/settings?line=error_token", 307)
})
/** GET /api/auth/line/callback
 * LINE OAuth redirect endpoint (browser -> worker).
 * Forwards to POST handler to reuse token-exchange logic.
 */
app.get("/api/auth/line/callback", async (c) => {
  // SAFE MODE: handle GET callback end-to-end (no internal forward)
  const url = new URL(c.req.url)
  console.log("[LINE OAuth][callback:get] url=", url.toString())
  console.log("[LINE OAuth][callback:get] qs=", url.searchParams.toString())
  const code = url.searchParams.get("code") ?? ""
  const state = url.searchParams.get("state") ?? ""
  const tenantId = url.searchParams.get("tenantId") ?? state ?? getTenantId(c.req.raw)

  if (!code) {
    return c.redirect("http://localhost:3000/admin/settings?line=error_no_code", 307)
  }

  const res = await fetch(`${new URL(c.req.url).origin}/api/auth/line/callback`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ code, state, tenantId }),
  })

  const txt = await res.text()
  console.log("[LINE OAuth][callback:get->post] status=", res.status, "body=", txt)

  if (res.ok) {
    return c.redirect("http://localhost:3000/admin/settings?line=ok", 307)
  }
  return c.redirect("http://localhost:3000/admin/settings?line=error_token", 307)
})
app.post("/api/auth/line/callback", async (c) => {
  const env = c.env
  const body = await c.req.json<{
    code: string
    state?: string
    tenantId?: string
  }>()

  const tenantId = body.tenantId || getTenantId(c.req.raw)
  const code = body.code

  if (!code) {
    return c.json({ ok: false, error: "missing_code" }, 400)
  }

  const tokenUrl = "https://api.line.me/oauth2/v2.1/token"

  // auth-url ã§ä½¿ã£ãŸ redirect_uri ã¨å®Œå…¨ä¸€è‡´ã•ã›ã‚‹
  const redirectBase = env.LINE_LOGIN_REDIRECT_BASE ?? "http://localhost:3000"
  const redirectUri = `${redirectBase.replace(/\/$/, "")}/api/auth/line/callback`

  const clientId =
  (env.LINE_CLIENT_ID ?? "").trim() ||
  (env.LINE_LOGIN_CLIENT_ID ?? "").trim() ||
  (env.LINE_LOGIN_CHANNEL_ID ?? "").trim();

const clientSecret =
  (env.LINE_CLIENT_SECRET ?? "").trim() ||
  (env.LINE_LOGIN_CHANNEL_SECRET ?? "").trim();

if (!clientId) {
  return c.json({ ok: false, error: "LINE_CLIENT_ID is not configured" }, 500);
}
if (!clientSecret) {
  return c.json({ ok: false, error: "LINE_CLIENT_SECRET is not configured" }, 500);
}

console.log("[LINE][token] clientId.len=", clientId.length, "redirectUri=", redirectUri);

console.log("[LINE OAuth][token] clientId.len=", clientId.length, "clientSecret.len=", clientSecret.length, "redirectUri=", redirectUri);
const tokenBody = new URLSearchParams({
  grant_type: "authorization_code",
  code,
  redirect_uri: redirectUri,
  client_id: clientId,
  client_secret: clientSecret,
});
const tokenRes = await fetch(tokenUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      "Accept": "application/json",
    },
    body: tokenBody.toString(),
  })
  
  
  const tokenTxt = await tokenRes.clone().text()
  console.log("[LINE OAuth][token] status=", tokenRes.status, "body=", tokenTxt)

  // âœ… IMPORTANT: read tokenRes body ONLY ONCE
  const raw = await tokenRes.text()

  if (!tokenRes.ok) {
    console.error("[LINE][token] status=", tokenRes.status)
    console.error("[LINE][token] raw=", raw.slice(0, 800))
    return c.json({ ok: false, error: "token_request_failed", status: tokenRes.status, detail: raw }, 500)
  }

  let tokenJson: any
  try {
    tokenJson = JSON.parse(raw)
  } catch {
    console.error("[LINE][token] parse_failed raw=", raw.slice(0, 800))
    return c.json({ ok: false, error: "token_parse_failed", detail: raw }, 500)
  }

  if (!tokenJson?.access_token) {
    console.error("[LINE][token] missing_access_token json=", tokenJson)
    return c.json({ ok: false, error: "token_missing_access_token", detail: tokenJson }, 500)
  }

  if (!tokenJson.id_token) {
    return c.json({ ok: false, error: "missing_id_token" }, 500)
  }

  const verifyBody = new URLSearchParams({
    id_token: tokenJson.id_token,
    client_id: clientId,
  })

  const verifyRes = await fetch("https://api.line.me/oauth2/v2.1/verify", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: verifyBody.toString(),
  })

  if (!verifyRes.ok) {
    const text = await verifyRes.text()
    console.error("[LINE][verify] error", verifyRes.status, text)
    return c.json({ ok: false, error: "verify_failed" }, 500)
  }

  const v = (await verifyRes.json()) as any
  console.log("[LINE OAuth][verify] json=", JSON.stringify(v).slice(0, 800))

  const userId = (v?.sub ?? v?.userId ?? v?.user_id ?? "").toString().trim()
  const displayName = (v?.name ?? v?.displayName ?? "LINE User").toString()
  const pictureUrl = (v?.picture ?? v?.pictureUrl ?? v?.picture_url ?? undefined) as string | undefined

  if (!userId) {
    console.error("[LINE OAuth][verify] missing userId. json=", v)
    return c.json({ ok: false, error: "verify_missing_userid", detail: v }, 500)
  }

  const db = c.env.DB
  const now = new Date().toISOString()

  const saved = await upsertIntegration(db, tenantId, {
    userId: userId,
    displayName: displayName,
    pictureUrl: pictureUrl,
    updatedAt: now,
  })

  return c.json({
    ok: true,
    tenantId,
    kind: "linked" as const,
    line: {
      userId: saved.user_id,
      displayName: saved.display_name,
      pictureUrl: saved.picture_url || undefined,
      updatedAt: saved.updated_at,
    },
  })
})

app.patch("/admin/integrations/line/notify", async (c) => {
  const tenantId = c.req.query("tenantId") ?? "default"

  try {
    const body = await c.req.json().catch(() => ({} as any))
    const notifyEnabled = !!body?.notifyEnabled

    // D1ã® getIntegration ã‚’å‘¼ã¶
    const integration = await getIntegration(c.env.DB, tenantId)

    // integration === null ã®å ´åˆã¯å¿…ãš 409 ã‚’è¿”ã™
    if (integration === null) {
      return c.json({ ok: false, error: "not linked", tenantId, debug: "vD1-GUARD-20260125" }, 409)
    }

    // linked ã®å ´åˆã®ã¿ setNotifyEnabled ã‚’å®Ÿè¡Œ
    await setNotifyEnabled(c.env.DB, tenantId, notifyEnabled)

    // æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹
    return c.json({ ok: true, tenantId, notifyEnabled, debug: "vD1-GUARD-20260125" })
  } catch (e: any) {
    return c.json(
      { ok: false, error: "internal_error", message: String(e?.message ?? e), tenantId, debug: "vD1-GUARD-20260125" },
      500
    )
  }
})

app.post("/admin/integrations/line/test", async (c) => {
  const tenantId = c.req.query("tenantId") ?? "default"

  try {
    // D1ã® getIntegration ã‚’å‘¼ã¶
    const integration = await getIntegration(c.env.DB, tenantId)

    // integration === null ã®å ´åˆã¯å¿…ãš 409 ã‚’è¿”ã™
    if (integration === null) {
      return c.json({ ok: false, error: "not linked", tenantId, sent: false, debug: "vD1-GUARD-20260125" }, 409)
    }

    // linked ã®å ´åˆã®ã¿é€ä¿¡å‡¦ç†ï¼†ãƒ­ã‚° insert ã‚’è¡Œã†
    const now = Math.floor(Date.now() / 1000)

    // é€ä¿¡å‡¦ç†ï¼ˆä»®ã§ã‚‚OKï¼‰
    // ãƒ­ã‚° insert
    await c.env.DB.prepare(
      "INSERT INTO line_send_logs (tenant_id, kind, ok, message, error, created_at) VALUES (?1, ?2, ?3, ?4, ?5, ?6)"
    )
      .bind(tenantId, "test", 1, "dev test (guarded)", null, String(now))
      .run()

    // æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹
    return c.json({ ok: true, tenantId, sent: true, debug: "vD1-GUARD-20260125" })
  } catch (e: any) {
    const now = Math.floor(Date.now() / 1000)
    try {
      await c.env.DB.prepare(
        "INSERT INTO line_send_logs (tenant_id, kind, ok, message, error, created_at) VALUES (?1, ?2, ?3, ?4, ?5, ?6)"
      )
        .bind(tenantId, "test", 0, "dev test (guarded)", String(e?.message ?? e), String(now))
        .run()
    } catch {}

    return c.json(
      { ok: false, error: "internal_error", message: String(e?.message ?? e), tenantId, sent: false, debug: "vD1-GUARD-20260125" },
      500
    )
  }
})

// ãƒ«ãƒ¼ãƒˆ: POST /admin/integrations/line/disconnect
app.post("/admin/integrations/line/disconnect", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? getTenantId(c.req.raw)
    const db = c.env.DB

    await disconnectIntegration(db, tenantId)

    return c.json({ ok: true, tenantId, disconnected: true })
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error"
    console.error("[LINE][disconnect] error:", errorMessage)
    return c.json({
      ok: false,
      error: "disconnect failed",
      tenantId: c.req.query("tenantId") ?? getTenantId(c.req.raw),
      message: errorMessage,
    }, 500)
  }
})

/**
 * ===== LINE Messaging API (official account) config =====
 * - Separate from LINE Login
 * - Tenant-scoped by tenantId query
 */
app.get("/admin/integrations/line/messaging/status", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? "default"
    const db = (c.env as any).DB
    const env = c.env as any
    const r = await getMessagingStatus(env, db, tenantId)
    return c.json(r, 200)
  } catch (e) {
    const msg = e instanceof Error ? e.message : "unknown"
    return c.json({ ok: false, error: "internal_server_error", message: msg }, 500)
  }
})

app.post("/admin/integrations/line/messaging/save", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? "default"
    const body = await c.req.json()
    const db = (c.env as any).DB
    const env = c.env as any
    const r = await saveMessagingConfig(env, db, tenantId, body)
    if (r?.ok === false) return c.json(r, 400)
    return c.json(r, 200)
  } catch (e) {
    const msg = e instanceof Error ? e.message : "unknown"
    return c.json({ ok: false, error: "internal_server_error", message: msg }, 500)
  }
})

app.delete("/admin/integrations/line/messaging", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? "default"
    const db = (c.env as any).DB
    const env = c.env as any
    const r = await deleteMessagingConfig(env, db, tenantId)
    return c.json(r, 200)
  } catch (e) {
    const msg = e instanceof Error ? e.message : "unknown"
    return c.json({ ok: false, error: "internal_server_error", message: msg }, 500)
  }
})
// ãƒ«ãƒ¼ãƒˆ: POST /admin/integrations/line/webhook
app.post("/admin/integrations/line/webhook", async (c) => {
  const tenantId = c.req.query("tenantId") ?? "default"
  const logId = crypto.randomUUID()
  const ts = new Date().toISOString()

  // 1) ã¾ãšã¯ raw ã‚’èª­ã‚€ï¼ˆJSONãŒå£Šã‚Œã¦ã¦ã‚‚è½ã¡ãªã„ï¼‰
  let raw = ""
  try {
    raw = await c.req.text()
  } catch {
    raw = ""
  }
  const bodyLen = raw.length

  // 2) æœ€ä½é™ã ã‘æŠœãï¼ˆå¤±æ•—ã—ã¦ã‚‚ nullï¼‰
  let eventType: string | null = null
  let msgType: string | null = null
  let replyToken: string | null = null
  let replyTokenLen: number | null = null
  let text: string | null = null

  try {
    const j = raw ? JSON.parse(raw) : null
    const ev = j?.events?.[0]
    if (ev) {
      eventType = (ev.type ?? null) as any
      msgType = (ev.message?.type ?? null) as any
      replyToken = (ev.replyToken ?? null) as any
      replyTokenLen = replyToken ? String(replyToken).length : null
      text = (ev.message?.text ?? null) as any
    }
  } catch {
    // ignore
  }

  // 3) dummy / no token / no text ã¯ reply ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆ0=skippedï¼‰
  const isDummy = replyToken === "dummy"
    // === BOOKING_LINK_BEGIN ===
    {
      const t = String((text as any) ?? '').trim();
      const norm = t.replace(/\s+/g,'');
      const isBooking =
        norm === 'äºˆç´„' ||
        norm === 'ã‚ˆã‚„ã' ||
        norm === 'reserve' ||
        norm.startsWith('äºˆç´„') ||
        norm.includes('äºˆç´„');

      if (isBooking) {
        const u = String((c.env as any).BOOKING_URL ?? '').trim();
        const url = u || 'https://9e5cb6a9.booking-ui-4pk-3y1.pages.dev';

        const accessToken = String(
          (c.env as any).LINE_CHANNEL_ACCESS_TOKEN ??
          (c.env as any).LINE_MESSAGING_CHANNEL_ACCESS_TOKEN ??
          ''
        ).trim();

        if (!accessToken) {
          console.log('[BOOKING_URL] access token missing');
          return;
        }

        // Buttons template (best UX)
        const payload = {
          replyToken,
          messages: [
            {
              type: 'template',
              altText: 'äºˆç´„ãƒšãƒ¼ã‚¸ã‚’é–‹ã',
              template: {
                type: 'buttons',
                title: 'äºˆç´„ãƒšãƒ¼ã‚¸',
                text: 'ä¸‹ã®ãƒœã‚¿ãƒ³ã‹ã‚‰äºˆç´„ã‚’é–‹å§‹ã—ã¦ã­ğŸ˜™',
                actions: [
                  { type: 'uri', label: 'äºˆç´„ã‚’é–‹å§‹', uri: url }
                ]
              }
            }
          ]
        };

        try {
          const r = await fetch('https://api.line.me/v2/bot/message/reply', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ' + accessToken
            },
            body: JSON.stringify(payload)
          });
          if (!r.ok) {
            const body = await r.text().catch(() => '');
            console.log('[BOOKING_URL] reply failed', r.status, body);
          }
        } catch (e) {
          console.log('[BOOKING_URL] reply exception', String(e));
        }
        return;
      }
    }
    // === BOOKING_LINK_END ===
const shouldSkip = !replyToken || isDummy || !text
  const replyStatus = shouldSkip ? 0 : 1 // 0=skipped, 1=queued(å¾Œã§å®Ÿè¡Œ)

  // 4) ã“ã“ãŒè‚ï¼šDBã‚„fetchã¯å…¨éƒ¨ waitUntil ã«æŠ•ã’ã¦ã€HTTPã¯å³è¿”ã™
  try {
    const work = (async () => {
      try {
        // table ensureï¼ˆã“ã“ãŒå›ºã¾ã£ã¦ã‚‚HTTPã¯è¿”ã£ãŸå¾Œï¼‰
        await c.env.DB.prepare(
          "CREATE TABLE IF NOT EXISTS line_webhook_logs (" +
            "id TEXT PRIMARY KEY," +
            "ts TEXT NOT NULL," +
            "tenant_id TEXT NOT NULL," +
            "event_type TEXT," +
            "msg_type TEXT," +
            "reply_token_len INTEGER," +
            "body_len INTEGER NOT NULL," +
            "reply_status INTEGER," +
            "reply_body TEXT" +
          ")"
        ).run()

        await c.env.DB.prepare(
          "CREATE INDEX IF NOT EXISTS idx_line_webhook_logs_tenant_ts " +
          "ON line_webhook_logs(tenant_id, ts)"
        ).run()

        // ã¾ãšã¯ãƒ­ã‚°ã‚’å…¥ã‚Œã‚‹ï¼ˆqueued / skippedï¼‰
        const initialBody =
          shouldSkip
            ? (isDummy ? "reply skipped (dummy replyToken)" : "no replyToken or text")
            : "queued"

        await c.env.DB.prepare(
          "INSERT INTO line_webhook_logs (id, ts, tenant_id, event_type, msg_type, reply_token_len, body_len, reply_status, reply_body) " +
          "VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)"
        )
          .bind(logId, ts, tenantId, eventType, msgType, replyTokenLen, bodyLen, shouldSkip ? 0 : 1, initialBody)
          .run()

        // reply ãŒå¿…è¦ãªå ´åˆã ã‘å®Ÿè¡Œ
        if (!shouldSkip) {
          const token = resolveLineChannelAccessToken(c.env)
          if (!token) {
            await c.env.DB.prepare(
              "UPDATE line_webhook_logs SET reply_status = ?2, reply_body = ?3 WHERE id = ?1"
            ).bind(logId, -1, "LINE_CHANNEL_ACCESS_TOKEN missing").run()
            return
          }

          // Reply APIï¼ˆ3ç§’ã§æ‰“ã¡åˆ‡ã‚Šï¼‰
          const ac = new AbortController()
          const t = setTimeout(() => ac.abort(), 3000)

          let status: number | null = null
          let body: string | null = null

          try {
            const r = await fetch("https://api.line.me/v2/bot/message/reply", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": "Bearer " + token,
              },
              body: JSON.stringify({
                replyToken,
                messages: [{ type: "text",
    text: "ok" }],
              }),
              signal: ac.signal,
            })
            status = r.status
            body = await r.text()
          } catch (e: any) {
            body = "fetch error: " + String(e?.message ?? e)
            status = -2
          } finally {
            clearTimeout(t)
          }

          // çµæœã‚’è¿½è¨˜
          await c.env.DB.prepare(
            "UPDATE line_webhook_logs SET reply_status = ?2, reply_body = ?3 WHERE id = ?1"
          )
            .bind(logId, status, (body ?? "").slice(0, 2000))
            .run()
        }
      } catch {
        // ignoreï¼ˆãƒ­ã‚°å¤±æ•—ã§ã‚‚OKï¼‰
      }
    })()

    // å‹ãŒã†ã‚‹ã•ã„æ™‚ãŒã‚ã‚‹ã®ã§ any ã§é€ƒãŒã™ï¼ˆå®Ÿé‹ç”¨å„ªå…ˆï¼‰
    ;(c as any).executionCtx?.waitUntil?.(work)
  } catch {
    // ignore
  }

  return c.json({ ok: true, logged: true, logId, replyStatus })
})

// ãƒ«ãƒ¼ãƒˆ: GET /admin/integrations/line/webhook-logs
// Webhookãƒ­ã‚°ä¸€è¦§å–å¾—
app.get("/admin/integrations/line/webhook-logs", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? "default"
    const limit = Math.min(parseInt(c.req.query("limit") || "30", 10), 200)

    const rows = await c.env.DB.prepare(
      "SELECT id, ts, tenant_id, event_type, msg_type, reply_status FROM line_webhook_logs WHERE tenant_id = ?1 ORDER BY ts DESC LIMIT ?2"
    )
      .bind(tenantId, limit)
      .all<{
        id: string
        ts: string
        tenant_id: string
        event_type: string | null
        msg_type: string | null
        reply_status: number | null
      }>()

    return c.json({
      ok: true,
      rows: rows.results || [],
    })
  } catch (e: any) {
    return c.json(
      { ok: false, error: "internal_error", message: String(e?.message ?? e) },
      500
    )
  }
})

// ãƒ«ãƒ¼ãƒˆ: GET /admin/integrations/line/webhook-log
// Webhookãƒ­ã‚°è©³ç´°å–å¾—
app.get("/admin/integrations/line/webhook-log", async (c) => {
  try {
    const id = c.req.query("id")
    if (!id) {
      return c.json({ ok: false, error: "missing_id" }, 400)
    }

    const row = await c.env.DB.prepare(
      "SELECT * FROM line_webhook_logs WHERE id = ?1 LIMIT 1"
    )
      .bind(id)
      .first<{
        id: string
        ts: string
        tenant_id: string
        event_type: string | null
        msg_type: string | null
        reply_token_len: number | null
        body_len: number
        reply_status: number | null
        reply_body: string | null
      }>()

    if (!row) {
      return c.json({ ok: false, error: "not_found" }, 404)
    }

    return c.json({
      ok: true,
      log: row,
    })
  } catch (e: any) {
    return c.json(
      { ok: false, error: "internal_error", message: String(e?.message ?? e) },
      500
    )
  }
})

// ãƒ«ãƒ¼ãƒˆ: GET /ping
app.get("/ping", (c) => c.text("pong"))


// POST /admin/integrations/line/oauth/callback
app.post('/admin/integrations/line/oauth/callback', async (c) => {
  try {
    const body = await c.req.json<{ code?: string; state?: string }>();

    // code ã¨ state ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (!body.code || typeof body.code !== 'string' || body.code.trim() === '') {
      return c.json({ ok: false, error: 'code is required' }, 400);
    }
    if (!body.state || typeof body.state !== 'string' || body.state.trim() === '') {
      return c.json({ ok: false, error: 'state is required' }, 400);
    }

    // state ã‹ã‚‰ tenantId ã‚’æŠ½å‡º
    const stateParts = body.state.split(':');
    const tenantId = stateParts[0]?.trim();
    if (!tenantId) {
      return c.json({ ok: false, error: 'Invalid state: tenantId is missing' }, 400);
    }

    // ç’°å¢ƒå¤‰æ•°ã‹ã‚‰ LINE è¨­å®šã‚’å–å¾—
    const clientId = c.env.LINE_CLIENT_ID;
    const clientSecret = c.env.LINE_LOGIN_CHANNEL_SECRET;
    
    // redirect_uri ã‚’å–å¾—ï¼ˆç’°å¢ƒå¤‰æ•°ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ç”¨ã€ãªã‘ã‚Œã°æ§‹ç¯‰ï¼‰
    let redirectUri: string;
    if (c.env.LINE_REDIRECT_URI) {
      redirectUri = c.env.LINE_REDIRECT_URI;
    } else if (c.env.LINE_LOGIN_REDIRECT_BASE) {
      redirectUri = `${c.env.LINE_LOGIN_REDIRECT_BASE.replace(/\/$/, '')}/admin/integrations/line/callback`;
    } else {
      return c.json({ ok: false, error: 'LINE_REDIRECT_URI or LINE_LOGIN_REDIRECT_BASE is not configured' }, 500);
    }

    if (!clientId) {
      return c.json({ ok: false, error: 'LINE_CLIENT_ID is not configured' }, 500);
    }
    if (!clientSecret) {
      return c.json({ ok: false, error: 'LINE_LOGIN_CHANNEL_SECRET is not configured' }, 500);
    }

    // LINE token ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å©ã
    let tokenResponse: {
      access_token: string;
      expires_in: number;
      token_type: string;
      refresh_token?: string;
      id_token?: string;
    };

    try {
      tokenResponse = await exchangeCodeForToken(body.code, clientId, clientSecret, redirectUri);
    } catch (tokenError) {
      // LINE token API ã®ã‚¨ãƒ©ãƒ¼ã‚’ãƒ­ã‚°ã«å‡ºåŠ›
      const errorMessage = tokenError instanceof Error ? tokenError.message : String(tokenError);
      console.error('[LINE OAuth Callback] Token exchange failed:', {
        status: errorMessage.includes('status') ? errorMessage : 'unknown',
        error: errorMessage,
        tenantId,
      });
      return c.json({ ok: false, error: 'line_token_error' }, 500);
    }

    // expires_at ã‚’è¨ˆç®—
    const now = Math.floor(Date.now() / 1000);
    const expiresAt = now + tokenResponse.expires_in;

    // D1 ã« upsert
    const db = c.env.DB;
    const createdAt = now;
    const updatedAt = now;

    try {
      await db
        .prepare(
          `INSERT INTO line_connections
            (tenant_id, access_token, refresh_token, id_token, expires_at, created_at, updated_at)
          VALUES (?, ?, ?, ?, ?, ?, ?)
          ON CONFLICT(tenant_id) DO UPDATE SET
            access_token = excluded.access_token,
            refresh_token = excluded.refresh_token,
            id_token = excluded.id_token,
            expires_at = excluded.expires_at,
            updated_at = excluded.updated_at`
        )
        .bind(
          tenantId,
          tokenResponse.access_token,
          tokenResponse.refresh_token || null,
          tokenResponse.id_token || null,
          expiresAt,
          createdAt,
          updatedAt
        )
        .run();
    } catch (dbError) {
      console.error('[LINE OAuth Callback] D1 upsert failed:', {
        error: dbError instanceof Error ? dbError.message : String(dbError),
        tenantId,
      });
      return c.json({ ok: false, error: 'database_error' }, 500);
    }

    // æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹
    return c.json({ ok: true });
  } catch (error) {
    // JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ãªã©
    if (error instanceof SyntaxError) {
      return c.json({ ok: false, error: 'Invalid JSON body' }, 400);
    }
    console.error('[LINE OAuth Callback] Unexpected error:', error);
    return c.json({ ok: false, error: error instanceof Error ? error.message : String(error) }, 500);
  }
});

//
// LINE OAuth callback receiver (bridge endpoint)
// - called from web /api/auth/line/callback
// - keep defensive (accept JSON and query)
//
app.post("/admin/integrations/line/callback", async (c) => {
  try {
    let body: any = null
    try { body = await c.req.json() } catch { body = null }

    const q = c.req.query()
    const code  = (body?.code  ?? q?.code  ?? "").toString()
    const state = (body?.state ?? q?.state ?? "").toString()
    const tenantId = (body?.tenantId ?? q?.tenantId ?? state ?? "default").toString() || "default"

    if (!code) {
      return c.json({ ok: false, error: "missing_code", tenantId }, 400)
    }

    // TODO: connect to existing token-exchange + D1 save logic.
    return c.json({ ok: true, tenantId, received: { hasCode: true, hasState: !!state } }, 200)
  } catch (e: any) {
    return c.json({ ok: false, error: "callback_exception", message: String(e?.message ?? e) }, 500)
  }
})

export default app

import { SlotLock as SlotLockImpl } from "./durable/SlotLock";

// Wrangler åˆ¤å®šç”¨ï¼šentrypoint ã§ export class SlotLock ã‚’ç›´æ¥è¦‹ã›ã‚‹
export class SlotLock extends SlotLockImpl {}











































