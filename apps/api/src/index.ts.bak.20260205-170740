import { Hono } from "hono"
import {
  getIntegration,
  upsertIntegration,
  setNotifyEnabled,
  disconnectIntegration,
  insertSendLog,
} from "./integrations/line/store"

// SAAS-FACTORY API ENTRY (apps/api/src/index.ts)
import { getMessagingStatus, saveMessagingConfig, deleteMessagingConfig } from "./integrations/line/messaging"

type Env = {
  DB: D1Database
  LINE_CLIENT_ID?: string
  LINE_LOGIN_CHANNEL_ID?: string
  LINE_LOGIN_CHANNEL_SECRET?: string
  LINE_LOGIN_REDIRECT_BASE?: string
  LINE_CHANNEL_ACCESS_TOKEN?: string
  LINE_MESSAGING_CHANNEL_ACCESS_TOKEN?: string
}

const app = new Hono<{ Bindings: Env }>()

/* ===== FIX7: SlotLock entrypoint export ===== */
// Wrangler åˆ¤å®šç”¨ï¼šentrypoint ã§ export class SlotLock ã‚’ç›´æŽ¥è¦‹ã›ã‚‹
/* ===== END FIX7 ===== */

/* ===== FIX6: RESTORE LOCALS (DEFAULT_ADMIN_SETTINGS + getBusinessHoursForDate) ===== */
const DEFAULT_ADMIN_SETTINGS = {
  timezone: "Asia/Tokyo",
  slotMinutes: 30,
  cutoffMinutes: 0,
  businessHours: { start: "09:00", end: "20:00" },
  closedWeekdays: [],
} as const;
function getBusinessHoursForDate(...args: any[]) {
  // Signature-agnostic: tries to locate a settings-like object in args.
  const settings =
    args.find(a => a && typeof a === "object" && (a.businessHours || a.closedWeekdays || a.timezone)) ??
    DEFAULT_ADMIN_SETTINGS;

  const dateArg = args.find(a => typeof a === "string" || a instanceof Date) ?? null;

  // If closedWeekdays matches weekday (0=Sun..6=Sat), mark closed.
  try {
    if(dateArg && Array.isArray((settings as any).closedWeekdays) && (settings as any).closedWeekdays.length){
      const d = (dateArg instanceof Date) ? dateArg : new Date(String(dateArg) + "T00:00:00+09:00");
      const wd = d.getDay();
      if((settings as any).closedWeekdays.includes(wd)){
        return { start: "00:00", end: "00:00", closed: true };
      }
    }
  } catch {}

  return (settings as any).businessHours ?? { start: "09:00", end: "20:00" };
}
/* ===== END FIX6 ===== */


app.get("/admin/integrations/line/messaging/status", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? "default"
    const db = (c.env as any).DB
    const env = c.env as any
    const r = await getMessagingStatus(env, db, tenantId)
    return c.json(r, 200)
  } catch (e) {
    const msg = e instanceof Error ? e.message : "unknown"
    return c.json({ ok: false, error: "internal_server_error", message: msg }, 500)
  }
})

app.post("/admin/integrations/line/messaging/save", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? "default"
    const body = await c.req.json()
    const db = (c.env as any).DB
    const env = c.env as any
    const r = await saveMessagingConfig(env, db, tenantId, body)
    if (r?.ok === false) return c.json(r, 400)
    return c.json(r, 200)
  } catch (e) {
    const msg = e instanceof Error ? e.message : "unknown"
    return c.json({ ok: false, error: "internal_server_error", message: msg }, 500)
  }
})

app.delete("/admin/integrations/line/messaging", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? "default"
    const db = (c.env as any).DB
    const env = c.env as any
    const r = await deleteMessagingConfig(env, db, tenantId)
    return c.json(r, 200)
  } catch (e) {
    const msg = e instanceof Error ? e.message : "unknown"
    return c.json({ ok: false, error: "internal_server_error", message: msg }, 500)
  }
})
// ãƒ«ãƒ¼ãƒˆ: POST /admin/integrations/line/webhook
app.post("/admin/integrations/line/webhook", async (c) => {
  const tenantId = c.req.query("tenantId") ?? "default"
  const logId = crypto.randomUUID()
  const ts = new Date().toISOString()

  // 1) ã¾ãšã¯ raw ã‚’èª­ã‚€ï¼ˆJSONãŒå£Šã‚Œã¦ã¦ã‚‚è½ã¡ãªã„ï¼‰
  let raw = ""
  try {
    raw = await c.req.text()
  } catch {
    raw = ""
  }
  const bodyLen = raw.length

  // 2) æœ€ä½Žé™ã ã‘æŠœãï¼ˆå¤±æ•—ã—ã¦ã‚‚ nullï¼‰
  let eventType: string | null = null
  let msgType: string | null = null
  let replyToken: string | null = null
  let replyTokenLen: number | null = null
  let text: string | null = null

  try {
    const j = raw ? JSON.parse(raw) : null
    const ev = j?.events?.[0]
    if (ev) {
      eventType = (ev.type ?? null) as any
      msgType = (ev.message?.type ?? null) as any
      replyToken = (ev.replyToken ?? null) as any
      replyTokenLen = replyToken ? String(replyToken).length : null
      text = (ev.message?.text ?? null) as any
    }
  } catch {
    // ignore
  }

  // 3) dummy / no token / no text ã¯ reply ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆ0=skippedï¼‰
  const isDummy = replyToken === "dummy"
    // === BOOKING_LINK_BEGIN ===
    {
      const t = String((text as any) ?? '').trim();
      const norm = t.replace(/\s+/g,'');
      const isBooking =
        norm === 'äºˆç´„' ||
        norm === 'ã‚ˆã‚„ã' ||
        norm === 'reserve' ||
        norm.startsWith('äºˆç´„') ||
        norm.includes('äºˆç´„');

      if (isBooking) {
        const u = String((c.env as any).BOOKING_URL ?? '').trim();
        const url = u || 'https://9e5cb6a9.booking-ui-4pk-3y1.pages.dev';

        const accessToken = String(
          (c.env as any).LINE_CHANNEL_ACCESS_TOKEN ??
          (c.env as any).LINE_MESSAGING_CHANNEL_ACCESS_TOKEN ??
          ''
        ).trim();

        if (!accessToken) {
          console.log('[BOOKING_URL] access token missing');
          return;
        }

        // Buttons template (best UX)
        const payload = {
          replyToken,
          messages: [
            {
              type: 'template',
              altText: 'äºˆç´„ãƒšãƒ¼ã‚¸ã‚’é–‹ã',
              template: {
                type: 'buttons',
                title: 'äºˆç´„ãƒšãƒ¼ã‚¸',
                text: 'ä¸‹ã®ãƒœã‚¿ãƒ³ã‹ã‚‰äºˆç´„ã‚’é–‹å§‹ã—ã¦ã­ðŸ˜™',
                actions: [
                  { type: 'uri', label: 'äºˆç´„ã‚’é–‹å§‹', uri: url }
                ]
              }
            }
          ]
        };

        try {
          const r = await fetch('https://api.line.me/v2/bot/message/reply', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ' + accessToken
            },
            body: JSON.stringify(payload)
          });
          if (!r.ok) {
            const body = await r.text().catch(() => '');
            console.log('[BOOKING_URL] reply failed', r.status, body);
          }
        } catch (e) {
          console.log('[BOOKING_URL] reply exception', String(e));
        }
        return;
      }
    }
    // === BOOKING_LINK_END ===
const shouldSkip = !replyToken || isDummy || !text
  const replyStatus = shouldSkip ? 0 : 1 // 0=skipped, 1=queued(å¾Œã§å®Ÿè¡Œ)

  // 4) ã“ã“ãŒè‚ï¼šDBã‚„fetchã¯å…¨éƒ¨ waitUntil ã«æŠ•ã’ã¦ã€HTTPã¯å³è¿”ã™
  try {
    const work = (async () => {
      try {
        // table ensureï¼ˆã“ã“ãŒå›ºã¾ã£ã¦ã‚‚HTTPã¯è¿”ã£ãŸå¾Œï¼‰
        await c.env.DB.prepare(
          "CREATE TABLE IF NOT EXISTS line_webhook_logs (" +
            "id TEXT PRIMARY KEY," +
            "ts TEXT NOT NULL," +
            "tenant_id TEXT NOT NULL," +
            "event_type TEXT," +
            "msg_type TEXT," +
            "reply_token_len INTEGER," +
            "body_len INTEGER NOT NULL," +
            "reply_status INTEGER," +
            "reply_body TEXT" +
          ")"
        ).run()

        await c.env.DB.prepare(
          "CREATE INDEX IF NOT EXISTS idx_line_webhook_logs_tenant_ts " +
          "ON line_webhook_logs(tenant_id, ts)"
        ).run()

        // ã¾ãšã¯ãƒ­ã‚°ã‚’å…¥ã‚Œã‚‹ï¼ˆqueued / skippedï¼‰
        const initialBody =
          shouldSkip
            ? (isDummy ? "reply skipped (dummy replyToken)" : "no replyToken or text")
            : "queued"

        await c.env.DB.prepare(
          "INSERT INTO line_webhook_logs (id, ts, tenant_id, event_type, msg_type, reply_token_len, body_len, reply_status, reply_body) " +
          "VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)"
        )
          .bind(logId, ts, tenantId, eventType, msgType, replyTokenLen, bodyLen, shouldSkip ? 0 : 1, initialBody)
          .run()

        // reply ãŒå¿…è¦ãªå ´åˆã ã‘å®Ÿè¡Œ
        if (!shouldSkip) {
          const token = resolveLineChannelAccessToken(c.env)
          if (!token) {
            await c.env.DB.prepare(
              "UPDATE line_webhook_logs SET reply_status = ?2, reply_body = ?3 WHERE id = ?1"
            ).bind(logId, -1, "LINE_CHANNEL_ACCESS_TOKEN missing").run()
            return
          }

          // Reply APIï¼ˆ3ç§’ã§æ‰“ã¡åˆ‡ã‚Šï¼‰
          const ac = new AbortController()
          const t = setTimeout(() => ac.abort(), 3000)

          let status: number | null = null
          let body: string | null = null

          try {
            const r = await fetch("https://api.line.me/v2/bot/message/reply", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": "Bearer " + token,
              },
              body: JSON.stringify({
                replyToken,
                messages: [{ type: "text",
    text: "ok" }],
              }),
              signal: ac.signal,
            })
            status = r.status
            body = await r.text()
          } catch (e: any) {
            body = "fetch error: " + String(e?.message ?? e)
            status = -2
          } finally {
            clearTimeout(t)
          }

          // çµæžœã‚’è¿½è¨˜
          await c.env.DB.prepare(
            "UPDATE line_webhook_logs SET reply_status = ?2, reply_body = ?3 WHERE id = ?1"
          )
            .bind(logId, status, (body ?? "").slice(0, 2000))
            .run()
        }
      } catch {
        // ignoreï¼ˆãƒ­ã‚°å¤±æ•—ã§ã‚‚OKï¼‰
      }
    })()

    // åž‹ãŒã†ã‚‹ã•ã„æ™‚ãŒã‚ã‚‹ã®ã§ any ã§é€ƒãŒã™ï¼ˆå®Ÿé‹ç”¨å„ªå…ˆï¼‰
    ;(c as any).executionCtx?.waitUntil?.(work)
  } catch {
    // ignore
  }

  return c.json({ ok: true, logged: true, logId, replyStatus })
})

// ãƒ«ãƒ¼ãƒˆ: GET /admin/integrations/line/webhook-logs
// Webhookãƒ­ã‚°ä¸€è¦§å–å¾—
app.get("/admin/integrations/line/webhook-logs", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? "default"
    const limit = Math.min(parseInt(c.req.query("limit") || "30", 10), 200)

    const rows = await c.env.DB.prepare(
      "SELECT id, ts, tenant_id, event_type, msg_type, reply_status FROM line_webhook_logs WHERE tenant_id = ?1 ORDER BY ts DESC LIMIT ?2"
    )
      .bind(tenantId, limit)
      .all<{
        id: string
        ts: string
        tenant_id: string
        event_type: string | null
        msg_type: string | null
        reply_status: number | null
      }>()

    return c.json({
      ok: true,
      rows: rows.results || [],
    })
  } catch (e: any) {
    return c.json(
      { ok: false, error: "internal_error", message: String(e?.message ?? e) },
      500
    )
  }
})

// ãƒ«ãƒ¼ãƒˆ: GET /admin/integrations/line/webhook-log
// Webhookãƒ­ã‚°è©³ç´°å–å¾—
app.get("/admin/integrations/line/webhook-log", async (c) => {
  try {
    const id = c.req.query("id")
    if (!id) {
      return c.json({ ok: false, error: "missing_id" }, 400)
    }

    const row = await c.env.DB.prepare(
      "SELECT * FROM line_webhook_logs WHERE id = ?1 LIMIT 1"
    )
      .bind(id)
      .first<{
        id: string
        ts: string
        tenant_id: string
        event_type: string | null
        msg_type: string | null
        reply_token_len: number | null
        body_len: number
        reply_status: number | null
        reply_body: string | null
      }>()

    if (!row) {
      return c.json({ ok: false, error: "not_found" }, 404)
    }

    return c.json({
      ok: true,
      log: row,
    })
  } catch (e: any) {
    return c.json(
      { ok: false, error: "internal_error", message: String(e?.message ?? e) },
      500
    )
  }
})

// ãƒ«ãƒ¼ãƒˆ: GET /ping
app.get("/ping", (c) => c.text("pong-20260205-165830"))// ãƒ«ãƒ¼ãƒˆ: GET /health
app.get("/health", (c) => c.text("ok"))
// POST /admin/integrations/line/oauth/callback
app.post('/admin/integrations/line/oauth/callback', async (c) => {
  try {
    const body = await c.req.json<{ code?: string; state?: string }>();

    // code ã¨ state ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (!body.code || typeof body.code !== 'string' || body.code.trim() === '') {
      return c.json({ ok: false, error: 'code is required' }, 400);
    }
    if (!body.state || typeof body.state !== 'string' || body.state.trim() === '') {
      return c.json({ ok: false, error: 'state is required' }, 400);
    }

    // state ã‹ã‚‰ tenantId ã‚’æŠ½å‡º
    const stateParts = body.state.split(':');
    const tenantId = stateParts[0]?.trim();
    if (!tenantId) {
      return c.json({ ok: false, error: 'Invalid state: tenantId is missing' }, 400);
    }

    // ç’°å¢ƒå¤‰æ•°ã‹ã‚‰ LINE è¨­å®šã‚’å–å¾—
    const clientId = c.env.LINE_CLIENT_ID;
    const clientSecret = c.env.LINE_LOGIN_CHANNEL_SECRET;
    
    // redirect_uri ã‚’å–å¾—ï¼ˆç’°å¢ƒå¤‰æ•°ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ç”¨ã€ãªã‘ã‚Œã°æ§‹ç¯‰ï¼‰
    let redirectUri: string;
    if (c.env.LINE_REDIRECT_URI) {
      redirectUri = c.env.LINE_REDIRECT_URI;
    } else if (c.env.LINE_LOGIN_REDIRECT_BASE) {
      redirectUri = `${c.env.LINE_LOGIN_REDIRECT_BASE.replace(/\/$/, '')}/admin/integrations/line/callback`;
    } else {
      return c.json({ ok: false, error: 'LINE_REDIRECT_URI or LINE_LOGIN_REDIRECT_BASE is not configured' }, 500);
    }

    if (!clientId) {
      return c.json({ ok: false, error: 'LINE_CLIENT_ID is not configured' }, 500);
    }
    if (!clientSecret) {
      return c.json({ ok: false, error: 'LINE_LOGIN_CHANNEL_SECRET is not configured' }, 500);
    }

    // LINE token ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å©ã
    let tokenResponse: {
      access_token: string;
      expires_in: number;
      token_type: string;
      refresh_token?: string;
      id_token?: string;
    };

    try {
      tokenResponse = await exchangeCodeForToken(body.code, clientId, clientSecret, redirectUri);
    } catch (tokenError) {
      // LINE token API ã®ã‚¨ãƒ©ãƒ¼ã‚’ãƒ­ã‚°ã«å‡ºåŠ›
      const errorMessage = tokenError instanceof Error ? tokenError.message : String(tokenError);
      console.error('[LINE OAuth Callback] Token exchange failed:', {
        status: errorMessage.includes('status') ? errorMessage : 'unknown',
        error: errorMessage,
        tenantId,
      });
app.get("/__debug/routes", (c) => {
  // @ts-ignore
  const routes = (app as any).routes ?? null;
  return c.json({ ok: true, routes });
});

      return c.json({ ok: false, error: 'line_token_error' }, 500);
    }

    // expires_at ã‚’è¨ˆç®—
    const now = Math.floor(Date.now() / 1000);
    const expiresAt = now + tokenResponse.expires_in;

    // D1 ã« upsert
    const db = c.env.DB;
    const createdAt = now;
    const updatedAt = now;

    try {
      await db
        .prepare(
          `INSERT INTO line_connections
            (tenant_id, access_token, refresh_token, id_token, expires_at, created_at, updated_at)
          VALUES (?, ?, ?, ?, ?, ?, ?)
          ON CONFLICT(tenant_id) DO UPDATE SET
            access_token = excluded.access_token,
            refresh_token = excluded.refresh_token,
            id_token = excluded.id_token,
            expires_at = excluded.expires_at,
            updated_at = excluded.updated_at`
        )
        .bind(
          tenantId,
          tokenResponse.access_token,
          tokenResponse.refresh_token || null,
          tokenResponse.id_token || null,
          expiresAt,
          createdAt,
          updatedAt
        )
        .run();
    } catch (dbError) {
      console.error('[LINE OAuth Callback] D1 upsert failed:', {
        error: dbError instanceof Error ? dbError.message : String(dbError),
        tenantId,
      });
      return c.json({ ok: false, error: 'database_error' }, 500);
    }

    // æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹
    return c.json({ ok: true });
  } catch (error) {
    // JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ãªã©
    if (error instanceof SyntaxError) {
      return c.json({ ok: false, error: 'Invalid JSON body' }, 400);
    }
    console.error('[LINE OAuth Callback] Unexpected error:', error);
    return c.json({ ok: false, error: error instanceof Error ? error.message : String(error) }, 500);
  }
});

//

export default app

// __DO_EXPORT_BRIDGE_BEGIN
// NOTE: Cloudflare new_sqlite_classes requires the DO class to be exported by the entry script.
import { SlotLock as __DO_IMPL_SlotLock } from "./SlotLock.legacy";
export class SlotLock extends __DO_IMPL_SlotLock {}
// __DO_EXPORT_BRIDGE_END
app.get("/__routes", (c) => {
  // @ts-ignore
  const routes = (app as any).routes ?? null;
  return c.json({ ok: true, routes });
});
    : null;
  return c.json({ ok: true, routes });
});







