import { Hono } from "hono"
import {
  getIntegration,
  upsertIntegration,
  setNotifyEnabled,
  disconnectIntegration,
  insertSendLog,
} from "./integrations/line/store"

// SAAS-FACTORY API ENTRY (apps/api/src/index.ts)
type Env = {
  DB: D1Database
  LINE_CLIENT_ID?: string
  LINE_LOGIN_CHANNEL_ID?: string
  LINE_LOGIN_CHANNEL_SECRET?: string
  LINE_LOGIN_REDIRECT_BASE?: string
  LINE_CHANNEL_ACCESS_TOKEN?: string
  LINE_MESSAGING_CHANNEL_ACCESS_TOKEN?: string
}

const app = new Hono<{ Bindings: Env }>()

// tenantId がなければ default
const getTenantId = (req: Request): string => {
  const url = new URL(req.url)
  return url.searchParams.get("tenantId") ?? "default"
}

function resolveLineClientId(env: Env): string {
  return env.LINE_CLIENT_ID || env.LINE_LOGIN_CHANNEL_ID || ""
}

function resolveLineChannelAccessToken(env: Env): string {
  return env.LINE_CHANNEL_ACCESS_TOKEN || env.LINE_MESSAGING_CHANNEL_ACCESS_TOKEN || ""
}

async function pushLineMessage(env: Env, to: string, text: string): Promise<Response> {
  const token = resolveLineChannelAccessToken(env)
  if (!token) {
    return new Response(JSON.stringify({ ok: false, error: "LINE channel access token missing" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    })
  }

  return fetch("https://api.line.me/v2/bot/message/push", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${token}`,
    },
    body: JSON.stringify({
      to,
      messages: [{ type: "text", text }],
    }),
  })
}

// ルート: GET /
app.get("/", (c) => c.text("Hello from SaaS Factory API!"))

// ルート: GET /health
app.get("/health", (c) => {
  return c.json({
    ok: true,
    ts: new Date().toISOString(),
    env: "development",
    version: "1.0.0",
  })
})

app.get("/__debug_guard", (c) => {
  return c.json({ ok: true, guard: "vD1-GUARD-20260125" })
})

// ルート: GET /admin/integrations/line/auth-url?tenantId=xxx
// LINE OAuth 認証URLを生成するエンドポイント
app.get("/admin/integrations/line/auth-url", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? "default"
    const env = c.env

    // client_id 解決（既存ロジックを維持）
    const clientId = resolveLineClientId(env)

    // redirect_uri を構築（Next.js 側の callback に向ける）
    // ★ ここがポイント：
    //     .dev.vars の LINE_LOGIN_REDIRECT_BASE をそのまま使う
    //     例: http://localhost:3000  または http://localhost:8787
    const redirectBase = env.LINE_LOGIN_REDIRECT_BASE ?? "http://localhost:3000"
    const redirectUri = `${redirectBase.replace(/\/$/, "")}/admin/integrations/line/callback`

    if (!clientId) {
      return c.json(
        { ok: false, error: "LINE_CLIENT_ID is not configured" },
        400,
      )
    }

    const params = new URLSearchParams({
      response_type: "code",
      client_id: clientId,
      redirect_uri: redirectUri,
      scope: "profile openid",
      state: tenantId,
    })

    const url = `https://access.line.me/oauth2/v2.1/authorize?${params.toString()}`

    return c.json({ ok: true, url })
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error"
    console.error("[LINE OAuth] auth-url error:", errorMessage)

    return c.json(
      {
        ok: false,
        error: "internal_server_error",
        message: `LINE OAuth認証URLの生成に失敗しました: ${errorMessage}`,
      },
      500,
    )
  }
})

// ルート: GET /admin/integrations/line/status
app.get("/admin/integrations/line/status", async (c) => {
  try {
    const tenantId = getTenantId(c.req.raw)
    const db = c.env.DB

    const integration = await getIntegration(db, tenantId)

    if (!integration) {
      return c.json({
        ok: true,
        tenantId,
        kind: "unconfigured" as const,
      })
    }

    return c.json({
      ok: true,
      tenantId,
      kind: "linked" as const,
      line: {
        userId: integration.user_id,
        displayName: integration.display_name,
        pictureUrl: integration.picture_url || undefined,
        updatedAt: integration.updated_at,
      },
      notifyEnabled: integration.notify_enabled === 1,
      linkedAt: integration.linked_at,
    })
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error"
    console.error("[LINE][status] error:", errorMessage)
    return c.json({
      ok: false,
      tenantId: getTenantId(c.req.raw),
      kind: "error" as const,
      message: "Failed to fetch LINE integration status",
      error: errorMessage,
    }, 500)
  }
})

// ルート: POST /admin/integrations/line/callback
// Next 側から code を受け取って token 交換 → profile 取得
app.post("/admin/integrations/line/callback", async (c) => {
  const env = c.env
  const body = await c.req.json<{
    code: string
    state?: string
    tenantId?: string
  }>()

  const tenantId = body.tenantId || getTenantId(c.req.raw)
  const code = body.code

  if (!code) {
    return c.json({ ok: false, error: "missing_code" }, 400)
  }

  const tokenUrl = "https://api.line.me/oauth2/v2.1/token"

  // auth-url で使った redirect_uri と完全一致させる
  const redirectBase = env.LINE_LOGIN_REDIRECT_BASE ?? "http://localhost:3000"
  const redirectUri = `${redirectBase.replace(/\/$/, "")}/admin/integrations/line/callback`

  const tokenBody = new URLSearchParams({
    grant_type: "authorization_code",
    code,
    redirect_uri: redirectUri,
    client_id: env.LINE_LOGIN_CHANNEL_ID ?? "",
    client_secret: env.LINE_LOGIN_CHANNEL_SECRET ?? "",
  })

  const tokenRes = await fetch(tokenUrl, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: tokenBody.toString(),
  })

  if (!tokenRes.ok) {
    const text = await tokenRes.text()
    console.error("[LINE][token] error", tokenRes.status, text)
    return c.json({ ok: false, error: "token_request_failed" }, 500)
  }

  const tokenJson = await tokenRes.json() as { id_token?: string }

  if (!tokenJson.id_token) {
    return c.json({ ok: false, error: "missing_id_token" }, 500)
  }

  const verifyBody = new URLSearchParams({
    id_token: tokenJson.id_token,
    client_id: env.LINE_LOGIN_CHANNEL_ID ?? "",
  })

  const verifyRes = await fetch("https://api.line.me/oauth2/v2.1/verify", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: verifyBody.toString(),
  })

  if (!verifyRes.ok) {
    const text = await verifyRes.text()
    console.error("[LINE][verify] error", verifyRes.status, text)
    return c.json({ ok: false, error: "verify_failed" }, 500)
  }

  const profile = (await verifyRes.json()) as {
    sub: string
    name?: string
    picture?: string
    email?: string
  }

  const db = c.env.DB
  const now = new Date().toISOString()

  const saved = await upsertIntegration(db, tenantId, {
    userId: profile.sub,
    displayName: profile.name ?? "LINE User",
    pictureUrl: profile.picture,
    updatedAt: now,
  })

  return c.json({
    ok: true,
    tenantId,
    kind: "linked" as const,
    line: {
      userId: saved.user_id,
      displayName: saved.display_name,
      pictureUrl: saved.picture_url || undefined,
      updatedAt: saved.updated_at,
    },
  })
})

app.patch("/admin/integrations/line/notify", async (c) => {
  const tenantId = c.req.query("tenantId") ?? "default"

  try {
    const body = await c.req.json().catch(() => ({} as any))
    const notifyEnabled = !!body?.notifyEnabled

    // D1の getIntegration を呼ぶ
    const integration = await getIntegration(c.env.DB, tenantId)

    // integration === null の場合は必ず 409 を返す
    if (integration === null) {
      return c.json({ ok: false, error: "not linked", tenantId, debug: "vD1-GUARD-20260125" }, 409)
    }

    // linked の場合のみ setNotifyEnabled を実行
    await setNotifyEnabled(c.env.DB, tenantId, notifyEnabled)

    // 成功レスポンス
    return c.json({ ok: true, tenantId, notifyEnabled, debug: "vD1-GUARD-20260125" })
  } catch (e: any) {
    return c.json(
      { ok: false, error: "internal_error", message: String(e?.message ?? e), tenantId, debug: "vD1-GUARD-20260125" },
      500
    )
  }
})

app.post("/admin/integrations/line/test", async (c) => {
  const tenantId = c.req.query("tenantId") ?? "default"

  try {
    // D1の getIntegration を呼ぶ
    const integration = await getIntegration(c.env.DB, tenantId)

    // integration === null の場合は必ず 409 を返す
    if (integration === null) {
      return c.json({ ok: false, error: "not linked", tenantId, sent: false, debug: "vD1-GUARD-20260125" }, 409)
    }

    // linked の場合のみ送信処理＆ログ insert を行う
    const now = Math.floor(Date.now() / 1000)

    // 送信処理（仮でもOK）
    // ログ insert
    await c.env.DB.prepare(
      "INSERT INTO line_send_logs (tenant_id, kind, ok, message, error, created_at) VALUES (?1, ?2, ?3, ?4, ?5, ?6)"
    )
      .bind(tenantId, "test", 1, "dev test (guarded)", null, String(now))
      .run()

    // 成功レスポンス
    return c.json({ ok: true, tenantId, sent: true, debug: "vD1-GUARD-20260125" })
  } catch (e: any) {
    const now = Math.floor(Date.now() / 1000)
    try {
      await c.env.DB.prepare(
        "INSERT INTO line_send_logs (tenant_id, kind, ok, message, error, created_at) VALUES (?1, ?2, ?3, ?4, ?5, ?6)"
      )
        .bind(tenantId, "test", 0, "dev test (guarded)", String(e?.message ?? e), String(now))
        .run()
    } catch {}

    return c.json(
      { ok: false, error: "internal_error", message: String(e?.message ?? e), tenantId, sent: false, debug: "vD1-GUARD-20260125" },
      500
    )
  }
})

// ルート: POST /admin/integrations/line/disconnect
app.post("/admin/integrations/line/disconnect", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? getTenantId(c.req.raw)
    const db = c.env.DB

    await disconnectIntegration(db, tenantId)

    return c.json({ ok: true, tenantId, disconnected: true })
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error"
    console.error("[LINE][disconnect] error:", errorMessage)
    return c.json({
      ok: false,
      error: "disconnect failed",
      tenantId: c.req.query("tenantId") ?? getTenantId(c.req.raw),
      message: errorMessage,
    }, 500)
  }
})

// ルート: POST /admin/integrations/line/webhook
// LINE Webhook受信・返信・ログ保存
app.post("/admin/integrations/line/webhook", async (c) => {
  const tenantId = c.req.query("tenantId") ?? "default"
  const logId = crypto.randomUUID()
  const ts = new Date().toISOString()
  let eventType: string | null = null
  let msgType: string | null = null
  let replyTokenLen: number | null = null
  let bodyLen = 0
  let replyStatus = 0
  let replyBody: string | null = null

  try {
    // bodyText を必ず取得
    const bodyText = await c.req.text()
    bodyLen = bodyText.length

    // JSON parse（失敗しても記録）
    let body: any = null
    try {
      body = JSON.parse(bodyText)
    } catch (parseError) {
      // parse失敗でもD1に記録して200返す
      await c.env.DB.prepare(
        "INSERT INTO line_webhook_logs (id, ts, tenant_id, event_type, msg_type, reply_token_len, body_len, reply_status, reply_body) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)"
      )
        .bind(logId, ts, tenantId, null, null, null, bodyLen, -1, "JSON parse failed")
        .run()
      return c.json({ ok: true, logged: true, logId })
    }

    // events[0] を取り出し
    const events = body?.events || []
    const event = events[0] || null

    if (event) {
      eventType = event.type || null
      msgType = event.message?.type || null
      const replyToken = event.replyToken || null
      replyTokenLen = replyToken ? replyToken.length : null

      // dummy replyToken は LINE Reply API を呼ばない（ローカル疑似Webhook用）
      if (replyToken === "dummy") {        try {
          const p = c.env.DB
            .prepare(
            "INSERT INTO line_webhook_logs (id, ts, tenant_id, event_type, msg_type, reply_token_len, body_len, reply_status, reply_body) " +
            "VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)"
          )
          .bind(logId, ts, tenantId, eventType, msgType, replyTokenLen, bodyLen, 0, "reply skipped (dummy replyToken)")
          .run()
          // D1が詰まってもレスポンスは先に返す
          c.executionCtx?.waitUntil?.(p)
          p.catch(() => {})
        } catch {}return c.json({ ok: true, logged: true, logId, replyStatus: 0 })
      }

      // replyToken が無い or text が無い場合は記録だけして 200 返す
      if (!replyToken || !event.message?.text) {
        await c.env.DB.prepare(
          "INSERT INTO line_webhook_logs (id, ts, tenant_id, event_type, msg_type, reply_token_len, body_len, reply_status, reply_body) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)"
        )
          .bind(logId, ts, tenantId, eventType, msgType, replyTokenLen, bodyLen, 0, "no replyToken or text")
          .run()
        return c.json({ ok: true, logged: true, logId, skipped: true })
      }

      // env.LINE_CHANNEL_ACCESS_TOKEN が無ければ reply_status=-1 & reply_body に理由を保存し 200 返す
      const token = resolveLineChannelAccessToken(c.env)
      if (!token) {
        await c.env.DB.prepare(
          "INSERT INTO line_webhook_logs (id, ts, tenant_id, event_type, msg_type, reply_token_len, body_len, reply_status, reply_body) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)"
        )
          .bind(logId, ts, tenantId, eventType, msgType, replyTokenLen, bodyLen, -1, "LINE_CHANNEL_ACCESS_TOKEN missing")
          .run()
        return c.json({ ok: true, logged: true, logId, skipped: true })
      }

      // reply API呼び出し
      const text = event.message.text
      const replyRes = await fetch("https://api.line.me/v2/bot/message/reply", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`,
        },
        body: JSON.stringify({
          replyToken,
          messages: [{ type: "text", text: `echo: ${text}` }],
        }),
      })

      replyStatus = replyRes.status
      const replyText = await replyRes.text().catch(() => "")
      replyBody = replyText.length > 1000 ? replyText.substring(0, 1000) : replyText

      // D1に保存
      await c.env.DB.prepare(
        "INSERT INTO line_webhook_logs (id, ts, tenant_id, event_type, msg_type, reply_token_len, body_len, reply_status, reply_body) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)"
      )
        .bind(logId, ts, tenantId, eventType, msgType, replyTokenLen, bodyLen, replyStatus, replyBody)
        .run()

      return c.json({ ok: true, logged: true, logId, replyStatus })
    } else {
      // events[0] が無い場合
      await c.env.DB.prepare(
        "INSERT INTO line_webhook_logs (id, ts, tenant_id, event_type, msg_type, reply_token_len, body_len, reply_status, reply_body) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)"
      )
        .bind(logId, ts, tenantId, null, null, null, bodyLen, 0, "no events[0]")
        .run()
      return c.json({ ok: true, logged: true, logId, skipped: true })
    }
  } catch (e: any) {
    // エラーでも必ず200返す方針
    try {
      await c.env.DB.prepare(
        "INSERT INTO line_webhook_logs (id, ts, tenant_id, event_type, msg_type, reply_token_len, body_len, reply_status, reply_body) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)"
      )
        .bind(logId, ts, tenantId, eventType, msgType, replyTokenLen, bodyLen, -1, `error: ${String(e?.message ?? e)}`)
        .run()
    } catch {}
    return c.json({ ok: true, logged: true, logId, error: String(e?.message ?? e) })
  }
})

// ルート: GET /admin/integrations/line/webhook-logs
// Webhookログ一覧取得
app.get("/admin/integrations/line/webhook-logs", async (c) => {
  try {
    const tenantId = c.req.query("tenantId") ?? "default"
    const limit = Math.min(parseInt(c.req.query("limit") || "30", 10), 200)

    const rows = await c.env.DB.prepare(
      "SELECT id, ts, tenant_id, event_type, msg_type, reply_status FROM line_webhook_logs WHERE tenant_id = ?1 ORDER BY ts DESC LIMIT ?2"
    )
      .bind(tenantId, limit)
      .all<{
        id: string
        ts: string
        tenant_id: string
        event_type: string | null
        msg_type: string | null
        reply_status: number | null
      }>()

    return c.json({
      ok: true,
      rows: rows.results || [],
    })
  } catch (e: any) {
    return c.json(
      { ok: false, error: "internal_error", message: String(e?.message ?? e) },
      500
    )
  }
})

// ルート: GET /admin/integrations/line/webhook-log
// Webhookログ詳細取得
app.get("/admin/integrations/line/webhook-log", async (c) => {
  try {
    const id = c.req.query("id")
    if (!id) {
      return c.json({ ok: false, error: "missing_id" }, 400)
    }

    const row = await c.env.DB.prepare(
      "SELECT * FROM line_webhook_logs WHERE id = ?1 LIMIT 1"
    )
      .bind(id)
      .first<{
        id: string
        ts: string
        tenant_id: string
        event_type: string | null
        msg_type: string | null
        reply_token_len: number | null
        body_len: number
        reply_status: number | null
        reply_body: string | null
      }>()

    if (!row) {
      return c.json({ ok: false, error: "not_found" }, 404)
    }

    return c.json({
      ok: true,
      log: row,
    })
  } catch (e: any) {
    return c.json(
      { ok: false, error: "internal_error", message: String(e?.message ?? e) },
      500
    )
  }
})

// ルート: GET /ping
app.get("/ping", (c) => c.text("pong"))

export default app



